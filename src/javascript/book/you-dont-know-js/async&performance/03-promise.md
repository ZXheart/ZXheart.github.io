# :zzz:

[《你不知道的 JavaScript》](https://github.com/ZXheart/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch3.md)

# promises

在第二章中，我们定位了在使用回调表达程序异步性能和管理并发的两个主要类别的不足：缺乏顺序性和缺乏可靠性。现在我们更亲近的理解了问题，是时候将我们的注意力转向解决它们的模式了。

我们首先想要解决的是*控制反转*问题，信任是如此脆弱而且是如此的容易丢失。

回想一下，我们将我们的程序的延续包装进一个回调函数中，将这个回调交给另一个团体（甚至是潜在的外部代码），并双手合十祈祷它会做正确的事情并调用这个回调。

我们这么做是因为我们想说，“这是*将来*要发生的事，在当前的步骤完成之后。”

但是如果我们能够反向倒转这种*控制反转*呢？如果不是将我们程序的延续交给另一个团体，而是希望它返回给我们一个可以知道它何时完成的能力，然后我们的代码可以决定下一步做什么呢？

这个规范被称为**Promise**。

Promise 正在像风暴一样席卷 JS 世界，因为开发者和语言规范作者之流拼命的想要在他们的代码/设计中结束回调地狱的疯狂。事实上，大多数新被加入 JS/DOM 平台的异步 API 都是建立在 Promise 之上的。
所以深入学习它们可能是个好主意，你不这么认为吗？

> [!NOTE]
> “立即”这个词将在本章频繁使用，一般来说它指代一些 Promise 解析行为。然后，本质上在所有情况下，“立即”意味着就工作队列行为（参见第一章）而且，不是严格同步的*现在*的感觉。

## 什么是 Promise？

当开发者们决定要学习一种新技术或模式的时候，他们的第一步总是“给我看代码！”。摸着石头过河对我们来讲是十分自然的。

但事实上仅仅考察 API 丢失了一些抽象过程。Promise 是这样一种工具：从人们使用它的方式来看，无论他们是否理解它的用途和作用，还是仅仅学习和使用 API，都是很明显的。

所以在我展示 Promise 的代码之前，我想在概念上完整的解释一下 Promise 到底是什么。我希望这能更好的指引你探索如何将 Promise 理论整合到你自己的异步流程中。

带着这样的想法，让我们来看两种类比，来解释 Promise 是什么。

### 未来的值

想像这样的场景：我走到快餐店的柜台前，点了一个芝士汉堡。递给收银员 1.47 美元。通过点餐和付款，我为得到一个*值*（芝士汉堡）制造了一个请求。我发起了一个交易。

但是通常来说，芝士汉堡不会立即到我手中。收银员交给我一些东西代替我的芝士汉堡：一个带有点餐排队号的收据。这个点餐号是一个“我欠你”的许诺（Promise），它保证我最终会得到我的芝士汉堡。

于是我就拿着我的收据和点餐号。我知道它代表我的*未来的芝士汉堡*，所以我无需再担心它 —— 除了挨饿！

在我等待的时候，我可以做其他的事情，比如我给我的朋友发短信说，“嘿，一块儿吃午餐吗？我要吃芝士汉堡”。

我已经在用我的*未来的芝士汉堡*进行推理了，即便它还没有到我手中，我的大脑可以这么做是因为它将点餐号作为芝士汉堡的占位符号。这个占位符号实质上使这个值*与时间无关*。它是一个**未来的值**。

最终，我听到，“113 号！”。于是我愉快的拿着收据走到柜台前。我把收据给收银员，拿回我的芝士汉堡。

换句话说，一旦我的*未来的值*准备好，我就用我的许诺值换回值本身。

但还有另外一种可能的输出。他们叫我的号，但当我去取芝士汉堡时，收银员遗憾地告诉我，“对不起，看起来我们的芝士汉堡卖光了。”把这种场景下顾客有多沮丧放到一边，
我们可以看到*未来的值*的一个重要性质：它们既可以表示成功也可以表示失败。

每次我点芝士汉堡时，我都知道我要么最终得到一个芝士汉堡，要么得到芝士汉堡卖光的坏消息，并且不得不考虑中午吃点儿别的东西。

> [!NOTE]
> 在代码中，事情没有这么简单，因为还隐含着一种点餐号永远也不会被叫到的情况，这时我们就被搁置在了一种无限等待的未解析状态。我们待会儿再回头处理这种情况。

#### 现在和稍后的值

这一切也许听起来在思维上太过抽象而不能实施在你的代码中。那么，让我们更具体一些。

然而，在我们能介绍 Promise 是如何以这种方式工作之前，我们先看看我们已经明白的代码 —— 回调！ —— 是如何处理这些*未来值*的。

在你写代码来推导一个值时，比如在一个`number`上进行数学操作，不论你是否理解，对于这个值你已经假设了某些非常基础的事实 —— 这个值已经是一个实在的*现在*的值：

```javascript
var x,
  y = 2

console.log(x + y) // NaN  <-- 因为`x`还没有被赋值
```

`x + y`操作假定`x`和`y`都已经被设定好了。用我们一会将要阐述的术语来讲，我们假定`x`和`y`的值已经被*解析（resolve）* 了。

期盼`+`操作符本身能够魔法般的检测并等待`x`和`y`的值被解析（也就是准备好），然后才进行操作是无稽的。如果有些语句*现在*完成而其他的*稍后*完成，这就会在程序中造成混乱，对吧？

如果两个语句中的一个（或两者同时）可能还没有完成，你如何才能推断它们的关系呢？如果语句 2 要依赖语句 1 的完成，那么这里仅有两种输出：不是语句 1 *现在*立即完成而且一切处理正常进行，
就是语句 1 还没有完成，所以语句 2 将会失败。

如果这些东西听起来很像第一章的内容，很好！

回到我们的`x + y`的数学操作。想象有一种方法可以说，“讲`x`和`y`相加，但如果它们中任意一个还没有被设置，就等到它们都被设置。尽快将它们相加。”

你的大脑也许刚刚跳进回调。好吧，那么...

```javascript
function add(getX, getY, cb) {
  var x, y
  getX(function (xVal) {
    x = xVal
    // 两者都准备好了？
    if (y != undefined) {
      cb(x + y) // 发送加法的结果
    }
  })

  getY(function (yVal) {
    y = yVal
    // 两者都准备好了？
    if (x != undefined) {
      cb(x + y) // 发送加法的结果
    }
  })
}

// `fetchX()` 和 `fetchY()` 是同步或异步的函数
add(fetchX, fetchY, function (sum) {
  console.log(sum) // 很简单吧？
})
```

花点儿时间来感受下一段代码的美妙（或者丑陋），我耐心地等你。

虽然丑陋是无法否认的，但是关于这种异步模式有一些非常重要的事情需要注意。

在这段代码中，我们将`x`和`y`作为未来的值对待，我们将`add(..)`操作表达为：（从外部看来）它并不关心`x`或`y`或它们两者现在是否可用。换句话说，它泛化了*现在*和*稍后*，
如此我们可以信赖`add(..)`操作是一个可预测的结果。

通过使用一个临时一致的`add(..)` —— 它跨越*现在*和*稍后*的行为是相同的 —— 异步代码的推理变得容易得多了。

更直白的说：为了一致的处理*现在*和*稍后*，我们将它们都作为*稍后*：所有的操作都变成异步的。

当然，这种粗略的基于回调的方法留下了许多提升的空间。为了理解在不关心*未来的值*在时间上什么时候变得可用的情况下推理它而带来的好处，这仅仅是迈出的一小步。

#### Promise 值

我们绝对会在本章的后面深入更多关于 Promise 的细节 —— 所以如果这让你犯糊涂，不要担心 —— 但让我们先简单看一下我们如何通过`Promise`来表达`x + y`的例子：

```javascript
function add(xPromise, yPromise) {
  // `Promise.all([ .. ])`接收一个Promise的数组，并返回一个等待它们全部完成的新Promise
  return (
    Promise.all([xPromise, yPromise])

      // 当这个Promise被解析后，我们拿起收到的`X`和`Y`的值，并把它们相加
      .then(function (values) {
        // `values`是一个从先前被解析的Promise那里收到的消息数组
        return values[0] + values[1]
      })
  )
}

// `fetchX()` 和 `fetchY()` 返回相应值的Promise，这些只可能在 现在 或 稍后 准备好
add(fetchX(), fetchY())
  // 为了将两个数字相加，我们得到一个Promise。
  // 现在我们链式的调用`then(..)`来等待返回的Promise被解析
  .then(function (sum) {
    console.log(sum) // 这容易多了！
  })
```

在这个代码段中有两层 Promise。

`fetchX()`和`fetchY()`被直接调用，它们的返回值（promise！）被传入`add(..)`。这些 promise 表示的值将在*现在*或*稍后*准备好，但是每个 promise 都将行为泛化为与时间无关。
我们以一种时间无关的方式来推理`X`和`Y`的值。它们是*未来值*。

第二层是由`add(..)`创建（通过`Promise.all([ .. ])`）调用创建了一个 promise（它在等待`promiseX`和`promiseY`被解析）。链式调用`.then(..)`创建了另一个 promise，
它的`return values[0] + values[1]`这一行会被立即解析（是用加法的结果）。这样，我们链接在`add(..)`调用末尾的`then(..)`调用 —— 在代码段最后 —— 实际上是在第二个被返回的 promise 上
进行操作，而非被`Promise.all([ .. ])`创建的第一个 promise。另外，虽然我们没有在这第二个`then(..)`的末尾链接任何操作，它也已经创建了另一个 promise，我们可以选择监听/使用它。
这类 Promise 链的细节将会在本章后面进行讲解。

就像点一个芝士汉堡，Promise 的解析可能是一个拒绝（rejection）而非完成（fulfillment）。不同的是，被完成的 Promise 的值总是程序化的，而一个拒绝值 —— 通常被称为“拒绝理由” —— 既可以
被程序逻辑设置，也可以被运行时异常隐含的设置。

使用 Promise，`then(..)`调用实际上可以接受两个函数，第一个用作完成（正如刚才所示），而第二个用作拒绝：

```javascript
add(fetchX(), fetchY()).then(
  // 完成处理器
  function (sum) {
    console.log(sum)
  },
  // 拒绝处理器
  function (err) {
    console.error(err) // 倒霉！
  }
)
```

如果在取得`X`或`Y`时出现了错误，或在加法操作时某些事情不知怎得失败了，`add(..)`返回的 promise 就被拒绝了，传入`then(..)`的第二个错误处理函数会从 promise 那里收到拒绝的值。

因为 Promise 包装了事件相关的状态 —— 等待当前值的完成或拒绝 —— 从外部看来，Promise 本身是时间无关的，如此 Promise 就可以用可预测的方式组合，而不用关心时间或底层的结果。

另外，一旦 Promise 被解析，它就永远保持那个状态 —— 它的那个时刻变成了一个*不可变的值* —— 而且可以根据需要*被监听*任意多次。

> [!NOTE]
> 因为 Promise 一旦被解析就是外部不可变的，所以现在将这个值传递给任何其他团体都是安全的，而且我们知道它不会被意外或恶意的被修改。这在许多团体监听同一个 Promise 的解析时特别有用。一个团体
> 去影响另一个团体对 Promise 解析的监听能力是不可能的。不可变性听起来是一个学院派话题，但它实际上是 Promise 设计中最基础且最重要的方面之一，因此不能将它随意的跳过。

这是用于理解 Promise 的最强大且最重要的概念之一。通过大量的工作，你可以仅仅使用丑陋的回调组合来创建相同的效果，但这真的不是一个高效的策略，特别是你不得不一遍一遍的重复它。

Promise 是一种用来包装与组合*未来值*，并且可以很容易复用的机制。
