# :zzz:

[《你不知道的 JavaScript》](https://github.com/ZXheart/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch3.md)

# promises

在第二章中，我们定位了在使用回调表达程序异步性能和管理并发的两个主要类别的不足：缺乏顺序性和缺乏可靠性。既然我们对问题有了更深入的理解，那么是时候将我们的注意力转向能够解决这些问题的模式了。

我们首先想要解决的是*控制反转*问题，信任是如此脆弱而且是如此的容易丢失。

回想一下，我们将我们的程序的延续包装进一个回调函数中，将这个回调交给另一个团体（甚至可能是外部代码），并双手合十祈祷它会做正确的事情并调用这个回调。

我们这么做是因为我们想说，“这是*将来*要发生的事，在当前的步骤完成之后。”

但是如果我们能够反向倒转这种*控制反转*呢？如果不是将我们程序的延续交给另一个团体，而是希望它返回给我们一个可以知道它何时完成的能力，然后我们的代码可以决定下一步做什么呢？

这个规范被称为**Promise**。

Promise 正在像风暴一样席卷 JS 世界，因为开发者和语言规范作者之流拼命的想要在他们的代码/设计中结束回调地狱的疯狂。事实上，大多数新被加入 JS/DOM 平台的异步 API 都是建立在 Promise 之上的。
所以深入学习它们可能是个好主意，你不这么认为吗？

> [!NOTE]
> “立即”这个词将在本章频繁使用，一般来说它指代一些 Promise 解析行为。然后，本质上在所有情况下，“立即”意味着就工作（Job）队列行为（参见第一章）而且，不是严格同步的*现在*的感觉。

## 什么是 Promise？

当开发者们决定要学习一种新技术或模式的时候，他们的第一步总是“给我看代码！”。摸着石头过河对我们来讲是十分自然的。

但事实上仅仅考察 API 就会丢失很多抽象细节。Promise 是这样一种工具：从人们使用它的方式来看，很容易分辨他们是否理解它的用途和作用，还是仅仅学习和使用 API 而已。

所以在我展示 Promise 的代码之前，我想在概念上完整的解释一下 Promise 到底是什么。我希望这能更好的指引你探索如何将 Promise 理论整合到你自己的异步流程中。

带着这样的想法，让我们来看两种类比，来解释 Promise 是什么。

### 未来的值

想像这样的场景：我走到快餐店的柜台前，点了一个芝士汉堡。递给收银员 1.47 美元。通过点餐和付款，我为得到一个*值*（芝士汉堡）制造了一个请求。我发起了一个交易。

但是通常来说，芝士汉堡不会立即到我手中。收银员交给我一些东西代替我的芝士汉堡：一个带有点餐排队号的收据。这个点餐号是一个“我欠你”的承诺（Promise），它保证我最终会得到我的芝士汉堡。

于是我就拿着我的收据和点餐号。我知道它代表我的*未来的芝士汉堡*，所以我无需再担心它 —— 除了现在我还在挨饿！

在我等待的时候，我可以做其他的事情，比如我给我的朋友发短信说，“嘿，一块儿吃午餐吗？我正要吃芝士汉堡”。

我已经在用我的*未来的芝士汉堡*进行推理了，即便它还没有到我手中，我的大脑可以这么做是因为它将点餐号作为芝士汉堡的占位符号。从本质上讲，这个占位符号使这个值*与时间无关*。它是一个**未来的值**。

最终，我听到，“113 号！”。于是我愉快的拿着收据走到柜台前。我把收据给收银员，拿回我的芝士汉堡。

换句话说，一旦我的*未来的值*准备好，我就用我的承诺值换回值本身。

但还有另外一种可能的输出。他们叫我的号，但当我去取芝士汉堡时，收银员遗憾地告诉我，“对不起，看起来我们的芝士汉堡卖光了。”把这种场景下顾客有多沮丧放到一边，
我们可以看到*未来的值*的一个重要性质：它们既可以表示成功也可以表示失败。

每次我点芝士汉堡时，我都知道我要么最终得到一个芝士汉堡，要么得到芝士汉堡卖光的坏消息，并且不得不考虑中午吃点儿别的东西。

> [!NOTE]
> 在代码中，事情没有这么简单，因为还隐含着一种点餐号永远也不会被叫到的情况，这时我们就被搁置在了一种无限等待的未决议状态。我们待会儿再回头处理这种情况。

#### 现在和将来的值

这一切也许听起来在思维上太过抽象而不能实施在你的代码中。那么，让我们更具体一些。

然而，在我们能介绍 Promise 是如何以这种方式工作之前，我们先看看我们已经明白的代码 —— 回调！ —— 是如何处理这些*未来值*的。

在你写代码来得到某个值时，比如在一个`number`上进行数学操作，不论你是否意识到，对于这个值你已经做了某些基本的假设 —— 这个值已经是一个具体的的*现在*值：

<!-- prettier-ignore -->
```javascript
var x, y = 2

console.log(x + y) // NaN  <-- 因为`x`还没有被赋值
```

运算`x + y`操作假定`x`和`y`都已经被设定好了。用我们一会将要阐述的术语来讲，我们假定`x`和`y`的值已经被*决议（resolve）* 了。

期盼`+`操作符本身能够魔法般的检测并等待`x`和`y`的值被决议（也就是准备好），然后才进行操作是没有意义的。如果有些语句*现在*完成而其他的*将来*完成，这就会在程序中造成混乱，对吧？

如果两个语句中的一个（或两者同时）可能还没有完成，你如何才能推断它们的关系呢？如果语句 2 要依赖语句 1 的完成，那么这里仅有两种输出：不是语句 1 *现在*立即完成而且一切处理正常进行，
就是语句 1 还没有完成，所以语句 2 将会失败。

如果这些东西听起来很像第一章的内容，很好！

回到我们的`x + y`的数学操作。想象有一种方法可以说，“将`x`和`y`相加，但如果它们中任意一个还没有被设置，就等到它们都被设置。尽快将它们相加。”

你的大脑也许想到了回调。好吧，那么...

```javascript
function add(getX, getY, cb) {
  var x, y
  getX(function (xVal) {
    x = xVal
    // 两者都准备好了？
    if (y != undefined) {
      cb(x + y) // 发送加法的结果
    }
  })

  getY(function (yVal) {
    y = yVal
    // 两者都准备好了？
    if (x != undefined) {
      cb(x + y) // 发送加法的结果
    }
  })
}

// `fetchX()` 和 `fetchY()` 是同步或异步的函数
add(fetchX, fetchY, function (sum) {
  console.log(sum) // 很简单吧？
})
```

花点儿时间来感受下一段代码的美妙（或者丑陋），我耐心地等你。

虽然丑陋是无法否认的，但是关于这种异步模式体现出了一些非常重要的事情。

在这段代码中，我们将`x`和`y`作为未来的值对待，我们将`add(..)`操作表达为：（从外部看来）它并不关心`x`或`y`或它们两者现在是否可用。换句话说，它泛化了*现在*和*将来*，
如此我们可以信赖`add(..)`操作是一个可预测的结果。

通过使用一个时间上一致的`add(..)` —— 它跨越*现在*和*将来*，期间的行为是一致的 —— 异步代码的推理变得容易得多了。

更直白的说：为了统一的处理*现在*和*将来*，我们将它们都作为*将来*：所有的操作都变成异步的。

当然，这种粗略的基于回调的方法留下了许多提升的空间。要体会追踪*未来值*的益处而不需要考虑其在时间方面是否可用，这仅仅是迈出的一小步。

#### Promise 值

我们绝对会在本章的后面深入更多关于 Promise 的细节 —— 所以如果这让你犯糊涂，不要担心 —— 但让我们先简单看一下我们如何通过`Promise`来表达`x + y`的例子：

```javascript
function add(xPromise, yPromise) {
  // `Promise.all([ .. ])`接收一个Promise的数组，并返回一个等待它们全部完成的新Promise
  return (
    Promise.all([xPromise, yPromise])

      // 当这个Promise决议后，我们拿起收到的`X`和`Y`的值，并把它们相加
      .then(function (values) {
        // `values`是一个从先前被解析的Promise那里收到的消息数组
        return values[0] + values[1]
      })
  )
}

// `fetchX()` 和 `fetchY()` 返回相应值的Promise，这些值可能在 现在 或 将来 准备好
add(fetchX(), fetchY())
  // 我们得到一个这两个数组的和的Promise。
  // 现在我们链式的调用`then(..)`来等待返回的Promise被决议
  .then(function (sum) {
    console.log(sum) // 这容易多了！
  })
```

在这个代码段中有两层 Promise。

`fetchX()`和`fetchY()`被直接调用，它们的返回值（promise！）被传入`add(..)`。这些 promise 表示的底层值的可用时间可能是*现在*或*将来*，不管怎样每个 promise 都将行为泛化为与时间无关。
我们以一种时间无关的方式来推理`X`和`Y`的值。它们是*未来值*。

第二层是由`add(..)`创建（通过`Promise.all([ .. ])`）并返回的 promise，我们通过调用`then(..)`来等待它。当`add(..)`操作完成后，我们的`sum`*未来值*就准备好并可以打印了。我们
将等待`X`和`Y`的*未来值*的逻辑隐藏在`add(..)`内部。

> [!NOTE]
> 在`add(..)`内部。`Promise.all([ .. ])`调用创建了一个 promise（它在等待`xPromise`和`yPromise`被决议）。链式调用`.then(..)`创建了另一个 promise，
> 它的`return values[0] + values[1]`这一行会被立即决议（得到加法运算的结果）。这样，我们链接在`add(..)`调用末尾的`then(..)`调用 —— 在代码段最后 —— 实际上是在第二个被返回
> 的 promise 上进行操作，而非被`Promise.all([ .. ])`创建的第一个 promise。另外，虽然我们没有在这第二个`then(..)`的末尾链接任何操作，它也已经创建了另一个 promise，
> 我们可以选择监听/使用它。这类 Promise 链的细节将会在本章后面进行讲解。

就像点一个芝士汉堡，Promise 的解析可能是一个拒绝（rejection）而非完成（fulfillment）。不同的是，被完成的 Promise 的值总是程序给出的，而一个拒绝值 —— 通常被称为“拒绝理由” —— 既可以
被程序逻辑设置，也可能是从运行时异常隐式得出的值。

使用 Promise，`then(..)`调用实际上可以接受两个函数，第一个用作完成（正如刚才所示），而第二个用作拒绝：

```javascript
add(fetchX(), fetchY()).then(
  // 完成处理器
  function (sum) {
    console.log(sum)
  },
  // 拒绝处理器
  function (err) {
    console.error(err) // 倒霉！
  }
)
```

如果在取得`X`或`Y`时出现了错误，或在加法操作时某些事情不知怎得失败了，`add(..)`返回的 promise 就被拒绝了，传入`then(..)`的第二个错误处理函数会从 promise 那里收到拒绝的值。

因为 Promise 包装了时间相关的状态 —— 等待底层值的完成或拒绝 —— 从外部看来，Promise 本身是时间无关的，如此 Promise 就可以用可预测的方式组合，而不用关心时间或底层的结果。

另外，一旦 Promise 决议，它就永远保持那个状态 —— 它的那个时刻变成了一个*不可变的值*（immutable value） —— 而且可以根据需要*被监听*任意多次。

> [!NOTE]
> 因为 Promise 一旦决议就是外部不可变的，所以现在将这个值传递给任何其他团体都是安全的，而且我们知道它不会被意外或恶意的被修改。这在许多团体监听同一个 Promise 的解析时特别有用。一个团体
> 去影响另一个团体对 Promise 决议的监听能力是不可能的。不可变性听起来是一个学院派话题，但它实际上是 Promise 设计中最基础且最重要的方面之一，因此不能将它随意的忽略。

这是关于 Promise 需要理解的最强大且最重要的概念之一。通过大量的工作，你可以仅仅使用丑陋的回调组合来创建相同的效果，但这真的不是一个高效的策略，特别是你不得不一遍一遍的重复它。

Promise 是一种用来包装与组合*未来值*，并且可以很容易复用的机制。

### 完成事件

正如我们刚才看到的，一个独立的 Promise 展示了*未来值*的特性。但还有另一种方式考虑 Promise 的决议：在一个异步任务的两个或以上步骤中，作为一种流程控制机制 —— 俗称“先这个然后那个”。

让我们想象调用`foo(..)`来执行某个任务。我们对它的细节一无所知，我们也不关心。它可能会立即完成任务，也可能会花一段时间完成。

我们仅仅想简单的知道`foo(..)`什么时候完成，以便于我们可以移动到下一个任务。换句话说，我们想要一种方法在`foo(..)`完成时得到通知，以便我们可以*继续*。

在典型的 JS 风格中，如果你需要监听一个通知，你很可能会想到事件（event）。那么我们可以将我们的通知需求重新表述为，监听由`foo(..)`发出的*完成*（或*继续*）事件。

> [!NOTE]
> 将它称为一个“完成事件”还是一个“继续事件”取决于你的角度。你是更关心`foo(..)`发生的事情，还是更关心`foo(..)`完成*之后*发生的事情？两种角度都对且都有用。事件通知告诉我们`foo(..)`
> 已经*完成*，也告诉我们可以*继续*进行下一个步骤。的确，你为了事件通知调用而传入的回调函数本身，在前面我们称它为一个*延续*（continuation）。因为*完成事件*更聚焦于`foo(..)`，
> 也就是我们当前注意的东西，所以在这篇文章的其余部分我们稍稍偏向于使用*完成事件*。

使用回调，“通知”就是被任务（`foo(..)`）调用的我们的回调函数。但是使用 Promise，我们将关系扭转过来，我们希望能在监听一个来自于`foo(..)`的事件，当我们被通知时，做相应的处理。

首先，考虑一些假想代码：

<!-- prettier ignore -->

```javascript
foo(x){
  // 开始做一些可能会花一段时间的事情
}

foo(42)

on(foo "completion") {
  // 现在我们可以做下一步了！
}

on(foo "error") {
  // 哦，不！`foo(..)`中某些事情搞错了
}
```

我们调用`foo(..)`然后我们设置两个事件监听器，一个给`"completion"`，一个给`"error"`。 —— `foo(..)`调用的两种可能的最终结果。实质上，`foo(..)`甚至不知道调用它的代码监听了这些事件，
这构成了一个非常美妙的*关注分离（separation of concerns）*。

不幸的是，这样的代码将需要 JS 环境不具备的一些“魔法”（而且显得有些不切实际）。这里是一种用 JS 表达它的更自然的方式：

<!-- prettier-ignore -->
```javascript
function foo(x) {
  // 开始做一些可能会花一段时间的事情


  // 制造一个`listener`事件通知能力并返回

  return listener
}

var evt = foo(42)

evt.on('completion', function () {
  // 现在我们可以做下一步了！
})

evt.on('error', function () {
  // 哦，不！`foo(..)`中某些事情搞错了
})
```

`foo(..)`明确的创建并返回了一个事件监听能力，调用方代码接受并在它上面注册了两个事件监听器。

很明显这反转了一般的面向回调代码，而且是有意为之。与将回调传入`foo(..)`相反，它返回一个我们称之为`evt`的事件能力，它接收回调。

但如果你回想第二章，回调本身代表着一种*控制反转*。所以反转回调模式实际上是*反转的反转*，或者说是一个*反转控制反转* —— 将控制权归还给调用代码，这也是我们最开始想要的效果。

一个重要的好处是，代码的多个分离部分都可以被赋予事件监听能力，而且它们都可在`foo(..)`完成时被独立的通知，来执行后续的步骤：

```javascript
var evt = foo(42)

// 让`bar(..)`监听`foo(..)`的完成
bar(evt)

// 同时，让`baz(..)`监听`foo(..)`的完成
baz(evt)
```

对控制反转的恢复实现了更好的*关注分离*，也就是`bar(..)`和`baz(..)`不必卷入`foo(..)`是如何被调用的问题。相似的，`foo(..)`也不必直到或关心`bar(..)`和`baz(..)`的存在或
它们是否在等待`foo(..)`完成的通知。

实质上，这个`evt`对象是一个中立的第三方协商机制，在分离的关注点之间进行交涉。

#### Promise “事件”

正如你可能已经猜到的，`evt`事件监听能力是一个 Promise 的类比。

在一个基于`Promise`的方式中，前面的代码将会使`foo(..)`创建并返回一个`Promise`实例，而且这个 promise 将会被传入`bar(..)`和`baz(..)`。

> [!NOTE]
> 我们监听的 Promise 解析“事件”并不是严格的事件（虽然它们为了某些目的表现得像事件），而且它们也不经常称为`"completion"`或`"error"`。相反，我们用`then(..)`来注册一个`then`事件。
> 或者也许更准确地讲，`then(..)`注册了`fulfillment(完成)`或`rejection(拒绝)`事件，虽然我们在代码中不会看到这些名词被明确的使用。

考虑：

```javascript
function foo(x) {
  // 开始写一些可能会花一段时间的事情

  // 构建并返回一个promise
  return new Promise(function (resolve, reject) {
    // 最终需要调用`resolve(..)`或`reject(..)`
    // 它们是这个promise的解析回调
  })
}

var p = foo(42)

bar(p)

baz(p)
```

> [!NOTE]
> 在`new Promise(function(..){ .. })`中展示的模式通常被称为“揭示构造器[^the-revealing-constructor-pattern]”。被传入的函数立即执行（不会被异步推迟，像`then(..)`的回调那样），
> 而且它被提供了两个参数，我们叫它们`resolve`和`reject`。这些是 Promise 的解析函数。`resolve(..)`一般表示完成，而`reject(..)`表示拒绝。

你可能猜到了`bar(..)`和`baz(..)`内部看起来是什么样子：

```javascript
function bar(fooPromise) {
  // 监听`foo(..)`的完成
  fooPromise.then(
    function () {
      // `foo(..)`现在完成了，那么做`bar(..)`的任务
    },
    function () {
      // 噢，在`foo(..)`中有某些事情搞错了
    }
  )
}

// `baz(..)`同上
```

Promise 解析没有必要一定发送消息，就像我们将 Promise 作为*将来值*考察时那样。它可以仅仅作为一种流程控制信号，就像前面的代码中那样使用。

另一种表达方式是：

```javascript
function bar() {
  // `foo(..)`绝对已经完成了，那么做`bar(..)`的任务
}

function oopsBar() {
  // 噢，在`foo(..)`中有些事情搞错了，那么`bar(..)`不会运行
}

// `baz()`和`oopsBaz()`同上

var p = foo(42)

p.then(bar, oopsBar)

p.then(baz, oopsBaz)
```

> [!NOTE]
> 如果你以前见过基于 Promise 的代码，你可能会相信这段代码的最后两行应当写作`p.then(..).then(..)`，使用链式，而不是`p.then(..); p.then(..)`。这将会是两种完全不同的行为，所以要小心！
> 这种区别现在看起来可能不明显，但是它们实际上是我们目前还没有见过的异步模式：分割(splitting)/分叉(forking)。不必担心！本章后面我们会回到这个话题。

与将 promise 实例`p`传入`bar(..)`和`baz(..)`相反，我们使用 promise 来控制`bar(..)`和`baz(..)`何时该运行（如果执行的话）。主要区别在于错误处理。

在第一个代码段的方式中，无论`foo(..)`是否成功`bar(..)`都会调用，如果被通知`foo(..)`失败了的话它提供自己的后备逻辑。显然，`baz(..)`也是这样做的。

两种方式本身都*对*。但会有一些情况使一种优于另一种。

在这两种方式中，从`foo(..)`返回的 promise`p`都被用于控制下一步发生什么。

另外，两个代码段都以对同一个 promise`p`调用两次`then(..)`结束，这展示了先前的观点，也就是 Promise（一旦被解析）会永远保持相同的解析结果（完成或拒绝），而且可以按需要后续的被监听任意多次。

无论何时`p`被解析，下一步都将总是相同的，包括*现在*和*将来*。

## Thenable 鸭子类型（Duck Typing）

在 Promise 的世界中，一个重要的细节是如何确定一个值是否是纯粹的 Promise。或者更直接地说，一个值会不会像 Promise 一样表现？

我们知道 Promise 是由`new Promise(..)`语法构建的，你可能会想`p instanceof Promise`将是一个可以接受的检查。但不幸的是，有几个理由表明它不是完全够用。

主要原因是，你可以从其他浏览器窗口中收到 Promise 值（iframe 等），其他的浏览器窗口会拥有自己的不同于当前窗口/iframe 的 Promise，这种检查将会在定位 Promise 实例时失效。

另外，一个库或框架可能会选择实现自己的 Promise 而不是用 ES6 原生的`Promise`实现。事实上，你很可能在根本没有 Promise 的老版本浏览器中通过一个库来使用 Promise。

当我们在本章稍后讨论 Promise 的解析过程时，为什么识别并同化一个非纯种但相似 Promise 的值仍然很重要会愈发明显。但目前只需要相信我，它是拼图中很重要的一块。

因此，人们决定识别一个 Promise（或像 Promise 一样表现的某些东西）的方法是定义一种称为“thenable”的东西，也就是任何拥有`then(..)`方法的对象或函数。这种方法假定任何这样的值都是一个符合
Promise 的 thenable。

根据值的形状（存在什么属性）来推测他的“类型”的“类型检查”有一个一般的名称，称为“鸭子类型检查” —— “如果它看起来像一只鸭子，并且叫起来像一只鸭子，那么它一定是一只鸭子”（参见本丛书的*类型与文法*）。
所以对 thenable 的鸭子类型检查可能大致是这样：

```javascript
if (p !== null && (typeof p === 'object' || typeof p === 'function') && typeof p.then === 'function') {
  // 认为它是一个thenable
} else {
  // 不是一个thenable
}
```

晕！先把将这种逻辑在各种地方实现有点丑陋的事实放在一边不谈，这里还有更多更深层的麻烦。

如果你试着用一个偶然拥有`then(..)`函数的任意对象/函数来完成一个 Promise，但你又没想把它当作一个 Promise/thenable 来对待，你的运气就用光了，因为它会被自动的识别为一个 thenable 并以特
殊的规则来对待（见本章后面的部分）。

如果你不知道一个值上面拥有`then(..)`就更是这样。比如：

```javascript
var o = { then: function () {} }

// 使`v`用`[[Prototype]]`链接到`o`
var v = Object.create(o)

v.someStuff = 'cool'
v.otherStuff = 'not so cool'

v.hasOwnProperty('then') // false
```

`v`看起来根本不像是一个 Promise 或 thenable。它只是一个拥有一些属性的普通对象。你可能只是想把这个值像其他对象那样传递而已。

但你不知道的是，`v`还`[[Prototype]]`链接着（见本丛书的*this 与对象原型*）另一个对象`o`，在它上面偶然拥有一个`then(..)`。所以 thenable 鸭子类型检查将会认为并假定`v`是一个 thenable。噢！

它甚至不需要直接故意这么做：

```javascript
Object.prototype.then = function () {}
Array.prototype.then = function () {}

var v1 = { hello: 'world' }
var v2 = ['Hello', 'World']
```

`v1`和`v2`都将被假定为是 thenable 的。你不能控制或预测是否有其他代码偶然或恶意的将`then(..)`加到`Object.prototype`，`Array.prototype`，或其他任何原生原型上。而且如果这个指定的
函数并不将它的任何参数作为回调调用，那么任何用这样的值被解析的 Promise 都将无声的永远挂起！疯狂。

听起来难以置信或不太可能？也许。

要知道，在 ES6 之前就有几种广为人知的非 Promise 库在社区中存在了，而且它们已经偶然拥有了称为`then(..)`的方法。这些库中的一些选择了重命名它们自己的方法来回避冲突（这很烂！）。另一些则因为
它们无法改变来回避冲突，简单的降级为“不兼容基于 Promise 的代码”的不幸状态。

标准化的决策“劫持”了原本非保留的、完全是通用的`then`属性名，这意味着任何值（或其委托对象），无论是过去，现在，还是将来，只要带有一个`then(..)`函数，不管是有意的还是偶然的，
都会被 Promise 系统误认为为一个 thenable（可以被处理为 Promise 的对象）。这种误判可能会导致一些非常难以追踪的 Bug。

> [!WARNING]
> 我并不喜欢我们最终采用了通过 thenable 的鸭子类型来识别 Promise 的方式。还有其他的选项，比如“标记化”`branding`或者“反标记化”`anti-branding`；但我们得到的方案似乎是一个最差的折中方案。
> 不过，这也不全是坏消息。正如我们稍后会看到的，“thenable”鸭子类型在某些情况下还是很有用的。但需要注意的是，如果它错误地将某些并非 Promise 的东西识别为 Promise，那就会变的非常危险。

## Promise 的信任

前面已经给出了两个很强的类比，用于解释 Promise 在不同方面能为我们的异步代码做些什么。但如果止步于此的话，我们就错过了 Promise 模式构建的可能最重要的特性：信任。

*将来值*和*完成事件*这两个类比在我们之前探讨的代码模式中很明显。但是，我们还不能一眼就看出 Promise 为什么以及如何用于解决 2.3 节列出的所有控制反转信任问题。稍微深入探究一下的话，我们
就不难发现它提供了一些重要的保护，重新建立了第 2 章中已经毁掉的异步编码可信任性。

先回顾一下只用回调编码的信任问题。把一个回调传入工具`foo(..)`时可能出现如下问题：

- 调用回调过早
- 调用回调过晚（或不被调用）
- 调用回调次数过少或过多
- 未能传递所需的环境和参数
- 吞掉可能出现的错误和异常

Promise 的特性就是专门用来为这些问题提供一个有效的可复用的答案。

### 调用过早

这个问题主要就是担心代码是否会引入类似 Zalgo 这样的副作用（参见第 2 章）。在这类问题中，一个任务有时同步完成，有时异步完成，这可能会导致“竞态条件[^race-condition]”。

根据定义，Promise 就不必担心这种问题，因为即使是立即完成的 Promise（类似于`new Promise(function(resolve){ resolve(42) })`）也无法被同步观察到。

也就是说，对一个 Promise 调用`then(..)`的时候，即使这个 Promise 已经决议，提供给`then(..)`的回调也总是异步调用（对此的更多讨论，请参见第一章的“Jobs”）。

不再需要插入你自己的`setTimeout(.., 0)`hack，Promise 会自动防止 Zalgo 出现。

### 调用过晚

和前面一点类似，Promise 创建对象调用`resolve(..)`或`reject(..)`时，这个 Promise 的`then(..)`注册的观察回调回被自动调度。可以确信，这些被调度的回调在下一个异步事件
点上一定会被触发（参见第一章的“Jobs”）。

同步查看是不可能的，所以一个同步任务链无法以这种方式运行来实现按照预期有效延迟另一个回调的发生。也就是说，一个 Promise 决议后，这个 Promise 上所有的通过`then(..)`注册的回调
都会在下一个异步时机点上依次被立即调用（再次提醒，请参见第一章“Jobs”）。这些回调中的任意一个都无法影响或延误对其他回调的调用。

```javascript
p.then(function () {
  p.then(function () {
    console.log('C')
  })
  console.log('A')
})

p.then(function () {
  console.log('B')
})

// A B C
```

这里，“C”无法打断或抢占“B”，这是因为 Promise 的运作方式。

#### Promise 调度技巧

但是，还有很重要的一点需要指出，有很多调度的细微差别。在这种情况下，两个独立 Promise 上链接的回调的相对顺序无法可靠预测。

如果两个 promise `p1`和`p2`都已经决议，那么`p1.then(..)`和`p2.then(..)`应该最终会先调用`p1`的回调，然后是`p2`的那些。但还有一些微妙的场景可能不是这样的，比如以下代码：

```javascript
var p3 = new Promise(function (resolve, reject) {
  resolve('B')
})

var p1 = new Promise(function (resolve, reject) {
  resolve(p3)
})

var p2 = new Promise(function (resolve, reject) {
  resolve('A')
})

p1.then(function (v) {
  console.log(v)
})

p2.then(function (v) {
  console.log(v)
})
// A B <-- 而不是你可能认为的 B A
```

后面我们还会深入介绍，但目前你可以看到，`p1`不是立即值而是用另一个 promise`p3`决议，后者本身决议为值“B”。规定的行为是把`p3`展开到`p1`，但是是异步的展开。
所以，在异步任务队列中，`p1`的回调排在`p2`的回调之后（参见第一章的“Jobs”）。

要避免这样的细微区别带来的噩梦，你永远不应该依赖于不同 Promise 间回调的顺序和调度。实际上，好的编码实践方案根本不会让多个回调的顺序有丝毫影响，可能的话就要避免。

### 回调未调用

这个问题很常见，Promise 可以通过几种途径解决。

首先，没有任何东西（甚至 JavaScript 错误）能阻止 Promise 向你通知它的决议（如果它决议了的话）。如果你对一个 Promise 注册了一个完成回调和一个拒绝回调，
那么 Promise 在决议时总是会调用其中的一个。

当然，如果你的回调函数本身包含 JavaScript 错误，那可能就会看不到你期望的结果，但实际上回调还是被调用了。后面我们会介绍如何在回调出错时得到通知，
因为就连这些错误也不会被吞掉。

但是，如果 Promise 本身永远不被决议呢？即使这样，Promise 也提供了解决方案，其使用了一种称为*竞态*的高级抽象机制：

```javascript
// 用于超时一个Promise的工具
function timeoutPromise(delay) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      reject('timeout!')
    }, delay)
  })
}

// 设置foo()超时
Promise.race([foo(), timeoutPromise(3000)]).then(
  function () {
    // foo()及时完成！
  },
  function (err) {
    // 或者foo()被拒绝，或者只是没能按时完成
    // 查看err来了解是那种情况
  }
)
```

关于这个 Promise 超时模式还有更多细节需要考量，后面我们会深入讨论。

很重要的一点是，我们可以保证一个`foo()`又一个输出信号，防止其永久挂住程序。

### 调用次数过少或过多

根据定义，回调被调用的正确次数应该是 1。“过少”的情况就是调用 0 次，和前面解释过的“未被”调用是同一种情况。

“过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次。如果出于某种原因，Promise 创建代码试图调用`resolve(..)`或`reject(..)`多次，或者试图两者都调用，
那么这个 Promise 将只会接受第一个决议，并默默地忽略任何后续调用。

由于 Promise 只能被决议一次，所以任何通过`then(..)`注册的（每个）回调就只能被调用一次。

当然，如果你把同一个回调注册了不止一次（比如`p.then(f); p.then(f)`），那它被调用的次数就会和注册次数相同。响应函数只会被调用一次，但这个保证并不能预防你搬起石头砸自己的脚。

### 未能传递参数/环境值

[^the-revealing-constructor-pattern]: [揭示构造器](https://blog.domenic.me/the-revealing-constructor-pattern/)
[^race-condition]: [竟态条件](https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3)
