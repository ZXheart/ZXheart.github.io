# :zzz:

[《你不知道的 JavaScript》](https://github.com/ZXheart/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch3.md)

# promises

在第二章中，我们定位了在使用回调表达程序异步性能和管理并发的两个主要类别的不足：缺乏顺序性和缺乏可靠性。既然我们对问题有了更深入的理解，那么是时候将我们的注意力转向能够解决这些问题的模式了。

我们首先想要解决的是*控制反转*问题，信任是如此脆弱而且是如此的容易丢失。

回想一下，我们将我们的程序的延续包装进一个回调函数中，将这个回调交给另一个团体（甚至可能是外部代码），并双手合十祈祷它会做正确的事情并调用这个回调。

我们这么做是因为我们想说，“这是*将来*要发生的事，在当前的步骤完成之后。”

但是如果我们能够反向倒转这种*控制反转*呢？如果不是将我们程序的延续交给另一个团体，而是希望它返回给我们一个可以知道它何时完成的能力，然后我们的代码可以决定下一步做什么呢？

这个规范被称为**Promise**。

Promise 正在像风暴一样席卷 JS 世界，因为开发者和语言规范作者之流拼命的想要在他们的代码/设计中结束回调地狱的疯狂。事实上，大多数新被加入 JS/DOM 平台的异步 API 都是建立在 Promise 之上的。
所以深入学习它们可能是个好主意，你不这么认为吗？

> [!NOTE]
> “立即”这个词将在本章频繁使用，一般来说它指代一些 Promise 解析行为。然后，本质上在所有情况下，“立即”意味着就工作（Job）队列行为（参见第一章）而且，不是严格同步的*现在*的感觉。

## 什么是 Promise？

当开发者们决定要学习一种新技术或模式的时候，他们的第一步总是“给我看代码！”。摸着石头过河对我们来讲是十分自然的。

但事实上仅仅考察 API 就会丢失很多抽象细节。Promise 是这样一种工具：从人们使用它的方式来看，很容易分辨他们是否理解它的用途和作用，还是仅仅学习和使用 API 而已。

所以在我展示 Promise 的代码之前，我想在概念上完整的解释一下 Promise 到底是什么。我希望这能更好的指引你探索如何将 Promise 理论整合到你自己的异步流程中。

带着这样的想法，让我们来看两种类比，来解释 Promise 是什么。

### 未来的值

想像这样的场景：我走到快餐店的柜台前，点了一个芝士汉堡。递给收银员 1.47 美元。通过点餐和付款，我为得到一个*值*（芝士汉堡）制造了一个请求。我发起了一个交易。

但是通常来说，芝士汉堡不会立即到我手中。收银员交给我一些东西代替我的芝士汉堡：一个带有点餐排队号的收据。这个点餐号是一个“我欠你”的承诺（Promise），它保证我最终会得到我的芝士汉堡。

于是我就拿着我的收据和点餐号。我知道它代表我的*未来的芝士汉堡*，所以我无需再担心它 —— 除了现在我还在挨饿！

在我等待的时候，我可以做其他的事情，比如我给我的朋友发短信说，“嘿，一块儿吃午餐吗？我正要吃芝士汉堡”。

我已经在用我的*未来的芝士汉堡*进行推理了，即便它还没有到我手中，我的大脑可以这么做是因为它将点餐号作为芝士汉堡的占位符号。从本质上讲，这个占位符号使这个值*与时间无关*。它是一个**未来的值**。

最终，我听到，“113 号！”。于是我愉快的拿着收据走到柜台前。我把收据给收银员，拿回我的芝士汉堡。

换句话说，一旦我的*未来的值*准备好，我就用我的承诺值换回值本身。

但还有另外一种可能的输出。他们叫我的号，但当我去取芝士汉堡时，收银员遗憾地告诉我，“对不起，看起来我们的芝士汉堡卖光了。”把这种场景下顾客有多沮丧放到一边，
我们可以看到*未来的值*的一个重要性质：它们既可以表示成功也可以表示失败。

每次我点芝士汉堡时，我都知道我要么最终得到一个芝士汉堡，要么得到芝士汉堡卖光的坏消息，并且不得不考虑中午吃点儿别的东西。

> [!NOTE]
> 在代码中，事情没有这么简单，因为还隐含着一种点餐号永远也不会被叫到的情况，这时我们就被搁置在了一种无限等待的未决议状态。我们待会儿再回头处理这种情况。

#### 现在和将来的值

这一切也许听起来在思维上太过抽象而不能实施在你的代码中。那么，让我们更具体一些。

然而，在我们能介绍 Promise 是如何以这种方式工作之前，我们先看看我们已经明白的代码 —— 回调！ —— 是如何处理这些*未来值*的。

在你写代码来得到某个值时，比如在一个`number`上进行数学操作，不论你是否意识到，对于这个值你已经做了某些基本的假设 —— 这个值已经是一个具体的的*现在*值：

<!-- prettier-ignore -->
```javascript
var x, y = 2

console.log(x + y) // NaN  <-- 因为`x`还没有被赋值
```

运算`x + y`操作假定`x`和`y`都已经被设定好了。用我们一会将要阐述的术语来讲，我们假定`x`和`y`的值已经被*决议（resolve）* 了。

期盼`+`操作符本身能够魔法般的检测并等待`x`和`y`的值被决议（也就是准备好），然后才进行操作是没有意义的。如果有些语句*现在*完成而其他的*将来*完成，这就会在程序中造成混乱，对吧？

如果两个语句中的一个（或两者同时）可能还没有完成，你如何才能推断它们的关系呢？如果语句 2 要依赖语句 1 的完成，那么这里仅有两种输出：不是语句 1 *现在*立即完成而且一切处理正常进行，
就是语句 1 还没有完成，所以语句 2 将会失败。

如果这些东西听起来很像第一章的内容，很好！

回到我们的`x + y`的数学操作。想象有一种方法可以说，“将`x`和`y`相加，但如果它们中任意一个还没有被设置，就等到它们都被设置。尽快将它们相加。”

你的大脑也许想到了回调。好吧，那么...

```javascript
function add(getX, getY, cb) {
  var x, y
  getX(function (xVal) {
    x = xVal
    // 两者都准备好了？
    if (y != undefined) {
      cb(x + y) // 发送加法的结果
    }
  })

  getY(function (yVal) {
    y = yVal
    // 两者都准备好了？
    if (x != undefined) {
      cb(x + y) // 发送加法的结果
    }
  })
}

// `fetchX()` 和 `fetchY()` 是同步或异步的函数
add(fetchX, fetchY, function (sum) {
  console.log(sum) // 很简单吧？
})
```

花点儿时间来感受下一段代码的美妙（或者丑陋），我耐心地等你。

虽然丑陋是无法否认的，但是关于这种异步模式体现出了一些非常重要的事情。

在这段代码中，我们将`x`和`y`作为未来的值对待，我们将`add(..)`操作表达为：（从外部看来）它并不关心`x`或`y`或它们两者现在是否可用。换句话说，它泛化了*现在*和*将来*，
如此我们可以信赖`add(..)`操作是一个可预测的结果。

通过使用一个时间上一致的`add(..)` —— 它跨越*现在*和*将来*，期间的行为是一致的 —— 异步代码的推理变得容易得多了。

更直白的说：为了统一的处理*现在*和*将来*，我们将它们都作为*将来*：所有的操作都变成异步的。

当然，这种粗略的基于回调的方法留下了许多提升的空间。要体会追踪*未来值*的益处而不需要考虑其在时间方面是否可用，这仅仅是迈出的一小步。

#### Promise 值

我们绝对会在本章的后面深入更多关于 Promise 的细节 —— 所以如果这让你犯糊涂，不要担心 —— 但让我们先简单看一下我们如何通过`Promise`来表达`x + y`的例子：

```javascript
function add(xPromise, yPromise) {
  // `Promise.all([ .. ])`接收一个Promise的数组，并返回一个等待它们全部完成的新Promise
  return (
    Promise.all([xPromise, yPromise])

      // 当这个Promise决议后，我们拿起收到的`X`和`Y`的值，并把它们相加
      .then(function (values) {
        // `values`是一个从先前被解析的Promise那里收到的消息数组
        return values[0] + values[1]
      })
  )
}

// `fetchX()` 和 `fetchY()` 返回相应值的Promise，这些值可能在 现在 或 将来 准备好
add(fetchX(), fetchY())
  // 我们得到一个这两个数组的和的Promise。
  // 现在我们链式的调用`then(..)`来等待返回的Promise被决议
  .then(function (sum) {
    console.log(sum) // 这容易多了！
  })
```

在这个代码段中有两层 Promise。

`fetchX()`和`fetchY()`被直接调用，它们的返回值（promise！）被传入`add(..)`。这些 promise 表示的底层值的可用时间可能是*现在*或*将来*，不管怎样每个 promise 都将行为泛化为与时间无关。
我们以一种时间无关的方式来推理`X`和`Y`的值。它们是*未来值*。

第二层是由`add(..)`创建（通过`Promise.all([ .. ])`）并返回的 promise，我们通过调用`then(..)`来等待它。当`add(..)`操作完成后，我们的`sum`*未来值*就准备好并可以打印了。我们
将等待`X`和`Y`的*未来值*的逻辑隐藏在`add(..)`内部。

> [!NOTE]
> 在`add(..)`内部。`Promise.all([ .. ])`调用创建了一个 promise（它在等待`xPromise`和`yPromise`被决议）。链式调用`.then(..)`创建了另一个 promise，
> 它的`return values[0] + values[1]`这一行会被立即决议（得到加法运算的结果）。这样，我们链接在`add(..)`调用末尾的`then(..)`调用 —— 在代码段最后 —— 实际上是在第二个被返回
> 的 promise 上进行操作，而非被`Promise.all([ .. ])`创建的第一个 promise。另外，虽然我们没有在这第二个`then(..)`的末尾链接任何操作，它也已经创建了另一个 promise，
> 我们可以选择监听/使用它。这类 Promise 链的细节将会在本章后面进行讲解。

就像点一个芝士汉堡，Promise 的解析可能是一个拒绝（rejection）而非完成（fulfillment）。不同的是，被完成的 Promise 的值总是程序给出的，而一个拒绝值 —— 通常被称为“拒绝理由” —— 既可以
被程序逻辑设置，也可能是从运行时异常隐式得出的值。

使用 Promise，`then(..)`调用实际上可以接受两个函数，第一个用作完成（正如刚才所示），而第二个用作拒绝：

```javascript
add(fetchX(), fetchY()).then(
  // 完成处理器
  function (sum) {
    console.log(sum)
  },
  // 拒绝处理器
  function (err) {
    console.error(err) // 倒霉！
  }
)
```

如果在取得`X`或`Y`时出现了错误，或在加法操作时某些事情不知怎得失败了，`add(..)`返回的 promise 就被拒绝了，传入`then(..)`的第二个错误处理函数会从 promise 那里收到拒绝的值。

因为 Promise 包装了时间相关的状态 —— 等待底层值的完成或拒绝 —— 从外部看来，Promise 本身是时间无关的，如此 Promise 就可以用可预测的方式组合，而不用关心时间或底层的结果。

另外，一旦 Promise 决议，它就永远保持那个状态 —— 它的那个时刻变成了一个*不可变的值*（immutable value） —— 而且可以根据需要*被监听*任意多次。

> [!NOTE]
> 因为 Promise 一旦决议就是外部不可变的，所以现在将这个值传递给任何其他团体都是安全的，而且我们知道它不会被意外或恶意的被修改。这在许多团体监听同一个 Promise 的解析时特别有用。一个团体
> 去影响另一个团体对 Promise 决议的监听能力是不可能的。不可变性听起来是一个学院派话题，但它实际上是 Promise 设计中最基础且最重要的方面之一，因此不能将它随意的忽略。

这是关于 Promise 需要理解的最强大且最重要的概念之一。通过大量的工作，你可以仅仅使用丑陋的回调组合来创建相同的效果，但这真的不是一个高效的策略，特别是你不得不一遍一遍的重复它。

Promise 是一种用来包装与组合*未来值*，并且可以很容易复用的机制。

### 完成事件

正如我们刚才看到的，一个独立的 Promise 展示了*未来值*的特性。但还有另一种方式考虑 Promise 的决议：在一个异步任务的两个或以上步骤中，作为一种流程控制机制 —— 俗称“先这个然后那个”。

让我们想象调用`foo(..)`来执行某个任务。我们对它的细节一无所知，我们也不关心。它可能会立即完成任务，也可能会花一段时间完成。

我们仅仅想简单的知道`foo(..)`什么时候完成，以便于我们可以移动到下一个任务。换句话说，我们想要一种方法在`foo(..)`完成时得到通知，以便我们可以*继续*。

在典型的 JS 风格中，如果你需要监听一个通知，你很可能会想到事件（event）。那么我们可以将我们的通知需求重新表述为，监听由`foo(..)`发出的*完成*（或*继续*）事件。

> [!NOTE]
> 将它称为一个“完成事件”还是一个“继续事件”取决于你的角度。你是更关心`foo(..)`发生的事情，还是更关心`foo(..)`完成*之后*发生的事情？两种角度都对且都有用。事件通知告诉我们`foo(..)`
> 已经*完成*，也告诉我们可以*继续*进行下一个步骤。的确，你为了事件通知调用而传入的回调函数本身，在前面我们称它为一个*延续*（continuation）。因为*完成事件*更聚焦于`foo(..)`，
> 也就是我们当前注意的东西，所以在这篇文章的其余部分我们稍稍偏向于使用*完成事件*。

使用回调，“通知”就是被任务（`foo(..)`）调用的我们的回调函数。但是使用 Promise，我们将关系扭转过来，我们希望能在监听一个来自于`foo(..)`的事件，当我们被通知时，做相应的处理。

首先，考虑一些假想代码：

<!-- prettier ignore -->

```javascript
foo(x){
  // 开始做一些可能会花一段时间的事情
}

foo(42)

on(foo "completion") {
  // 现在我们可以做下一步了！
}

on(foo "error") {
  // 哦，不！`foo(..)`中某些事情搞错了
}
```

我们调用`foo(..)`然后我们设置两个事件监听器，一个给`"completion"`，一个给`"error"`。 —— `foo(..)`调用的两种可能的最终结果。实质上，`foo(..)`甚至不知道调用它的代码监听了这些事件，
这构成了一个非常美妙的*关注分离（separation of concerns）*。

不幸的是，这样的代码将需要 JS 环境不具备的一些“魔法”（而且显得有些不切实际）。这里是一种用 JS 表达它的更自然的方式：

<!-- prettier-ignore -->
```javascript
function foo(x) {
  // 开始做一些可能会花一段时间的事情


  // 制造一个`listener`事件通知能力并返回

  return listener
}

var evt = foo(42)

evt.on('completion', function () {
  // 现在我们可以做下一步了！
})

evt.on('error', function () {
  // 哦，不！`foo(..)`中某些事情搞错了
})
```

`foo(..)`明确的创建并返回了一个事件监听能力 o，调用方代码接受并在它上面注册了两个事件监听器。

很明显这反转了一般的面向回调代码，而且是有意为之。与将回调传入`foo(..)`相反，它返回一个我们称之为`evt`的事件能力，它接收回调。

但如果你回想第二章，回调本身代表着一种*控制反转*。所以反转回调模式实际上是*反转的反转*，或者说是一个*反转控制反转* —— 将控制权归还给调用代码，这也是我们最开始想要的效果。

一个重要的好处是，代码的多个分离部分都可以被赋予事件监听能力，而且它们都可在`foo(..)`完成时被独立的通知，来执行后续的步骤：

```javascript
var evt = foo(42)

// 让`bar(..)`监听`foo(..)`的完成
bar(evt)

// 同时，让`baz(..)`监听`foo(..)`的完成
baz(evt)
```

对控制反转的恢复实现了更好的*关注分离*，也就是`bar(..)`和`baz(..)`不必卷入`foo(..)`是如何被调用的问题。相似的，`foo(..)`也不必直到或关心`bar(..)`和`baz(..)`的存在或
它们是否在等待`foo(..)`完成的通知。

实质上，这个`evt`对象是一个中立的第三方协商机制，在分离的关注点之间进行交涉。
