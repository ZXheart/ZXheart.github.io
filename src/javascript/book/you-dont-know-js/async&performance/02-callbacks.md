# :zzz:

[《你不知道的 JavaScript》](https://github.com/ZXheart/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch2.md)

# 回调

在第一章中，我们探讨了 JS 中关于异步编程的属于和概念。我们的焦点是理解驱动所有“事件”（异步函数调用）的单线程（一次一个）事件循环队列。我们还探讨了各种解释*同时*运行的事件链，
或“进程”（任务，函数调用等）间的关系的并发模式。

我们在第一章的所有例子中，将函数作为独立的，不可分割的操作单位使用，在这些函数内部语句按照可预知的顺序运行（在编译期水平之上！），但是在函数顺序水平上，事件（也就是异步函数调用）可以以各种顺序发生。

在所有这些情况中，函数都是一个“回调”。因为无论什么时候事件循环队列中的事件被处理时，这个函数都作为事件循环“调用并返回”程序的目标。

正如你观察到的，JS 程序中，回调是目前为止最常见的表达和管理异步的方式。确实，在 JS 语言中回调是最基础的异步模式。

无数的 JS 程序，即便是最精巧最复杂的程序，都曾经除了回调外不依靠任何其他异步模式而编写（当然，和我们在第一章中探讨的并发互动模式一起）。回调函数是 JS 的异步苦工，而且它工作得相当好。

除了...回调并不是没有缺点。许多开发者都对*Promises*提供的更好的异步模式感到兴奋不已。但是如果你不明白它在抽象什么，和为什么抽象，是不可能有效利用任何抽象机制的。

在本章中，我们将深入探讨这些话题，来说明为什么更精巧的异步模式（在本书的后续章节中讨论）是必要和被期望的。

## 延续

让我们回到在第一章中开始的异步回调的例子，但让我稍微修改它一下来画出重点：

```javascript
// A
ajax('..',function(..){
  // C
})
// B
```

`// A`和`// B`代表程序的前半部分（也就是*现在*），`// C`标识了程序的后半部分（也就是*将来*）。前半部分立即执行，然后会出现一个不知多久的“暂停”。在某个未来时刻，如果 Ajax 调用完成了，
那么程序会回到它刚才离开的地方，并*继续*执行后半部分。

换句话说，回调函数包装或封装了程序的*延续*。

让我们把代码弄得简单一些：

```javascript
// A
setTimeout(function () {
  // C
}, 1000)
// B
```

稍等片刻然后问你自己，你将如何描述（给一个不那么懂 JS 工作方式的人）这个程序的行为。来吧，大声说出来。这个很好的练习将使我的下一个观点更鲜明。

现在大多数读者可能在想或说着这样的话：“运行 A，然后设置一个等待 1000 毫秒的定时器，一旦它触发，就执行 C”。与你的版本有多接近？

你可能已经发觉了不对劲儿的地方，给了自己一个修正版：“运行 A，设置一个 1000 毫秒的定时器，然后运行 B，然后在定时器事件触发后，运行 C”。这比第一个版本更准确。你能发现不同之处吗？

虽然第二个版本更准确，但是对于以一种我们的大脑匹配代码，代码匹配 JS 引擎的方式讲解这段代码来说，这两个版本都是不足的。这里的鸿沟即是微小的也是巨大的，而且是理解回调作为异步表达和管理的缺点的关键。

只要我们以回调函数的方式引入一个延续（或者像许多程序员那样引入几十个！），我们就允许了一个分歧在我们的大脑的工作方式和代码的运行方式之间形成。当这两者背离时，我们的代码就不可避免地
陷入这样的境地：更难理解，更难推理，更难调试，更难维护。

## 顺序的大脑

我相信大多数读者都曾经听某个人说过（甚至你自己就曾这么说），“我能一心多用”。试图表现得一心多用的效果包含幽默（孩子们的拍头揉肚子游戏），平常的行为（边走边嚼口香糖），和彻头彻尾的危险（开车时发短信）。

但我们是一心多用的人吗？我们真的能执行两个意识，有意的一起行动并在完全同一时刻思考/推理它们两个吗？我们最高级的大脑功能有并行的多线程功能吗？

答案可能令你吃惊：**可能不是这样**。

我们的大脑其实就不是这样构成的。我们中大多数人（特别是 A 型人格！）都是自己不情愿承认的一个一心一用者。其实我们只能在任意给定的时刻考虑一件事。

我不是说我们所有的下意识，潜意识，大脑的自动功能，比如心跳和眨眼。那些都是我们延续生命的重要任务，我们不会有意识地给它们分配大脑的能量。谢天谢地，当我们在 3 分钟内第 15 次刷朋友圈时，我们的大脑在后台（线程！）继续着这些重要任务。

相反我们讨论的是在某时刻我们的意识最前线的任务。对我来说，是现在正在写这本书。我还在这完全同一时刻做其他高级的大脑活动吗？不，没有。我很快而且容易分心 —— 在这最后的几段中有几十次了！

当我们*模拟*一心多用时，比如试着在打字的同时和朋友或家人通电话，实际上我们表现得更像一个快速环境切换器。换句话说，我们快速交替的在两个或更多任务间来回切换，在微小，
快速的区块中*同时*处理每个任务。我们做的是如此之快，以至于从外界看来我们在*平行的*做这些事情。

难道这听起来不像异步事件并发吗？（就像 JS 中发生的那样）？！如果不，回去再读一遍第一张！

事实上，有一种方法可以将庞大复杂的神经内科世界简化为我希望可以在这里讨论的东西，那就是我们的大脑工作起来有点儿像事件循环队列。

如果你把我打的每一个字（或词）当作一个单独的异步事件，那么现在这一句话上就有十几处地方，可以让我的大脑被其他的事件打断，比如我的感觉，甚至只是我随机的想法。

我不会被打断，也不会一有机会就被拉到其他的“处理”上去（谢天谢地 —— 要不这本书永远也写不完了！）。但是它发生的也足够频繁，以至于我感到我的大脑几乎持续不断的切换到各种不同的环境（也就是“进程”）。
而这和 JS 引擎的感觉十分相像。

### 执行与计划

好了，这么说来我们的大脑可以被认为是运行在一个单线程事件循环队列中，就像 JS 引擎那样。这听起来是个不错的匹配。

但是我们需要比我们刚才分析得更加细致入微。在我们如何计划各种任务，和我们的大脑实际如何运行这些任务之间，有一个巨大，明显的不同。

再一次，回到这边文章的写作的比喻上来。在我心里的粗略计划轮廓是继续写啊写，顺序的经过一系列在我思想中定好的点。我没有在这次写作期间计划任何的打扰或非线性的活动。但无论如何，
我的大脑依然不停的切换。

即便在操作级别上我们的大脑是异步事件的，但我们还是用一种顺序的，同步的方式计划任务。“我得去商店，然后买些牛奶，然后去干洗店”。

你会注意到这种高级思维（规划）方式看起来不是那么“异步”。事实上，我们几乎很少会故意只用事件的形式思考。相反，我们小心，顺序的（A 然后 B 然后 C）计划，而且我们假设一个区间有某种
临时的阻塞迫使 B 等待 A，使 C 等待 B。

当开发者编写代码时，他们规划一组将要发生的动作。如果他们是合格的开发者，他们会**小心的规划**。比如“我需要将`z`的值设为`x`的值，然后将`x`的值设为`y`的值”。

当我们编写同步代码时，一个语句接一个语句，它工作起来就像我们的跑腿 todo 清单：

```javascript
// 交换`x`与`y`（通过临时变量`z`）
z = x
x = y
y = z
```

这三个赋值语句是同步的，所以`x = y`会等待`z = x`完成，而`y = z`会相应的等待`x = y`完成。另一种说法是这三个语句临时的按照特定的顺序绑在一起执行，一个接一个。
幸好我们不必在这里关心任何异步事件的细节。如果我们关心，代码很快就会变得非常复杂！

如果同步的大脑规划和同步的代码语句匹配的很好，那么我们的大脑能把异步代码规划的多好呢？

事实证明，我们在代码中表达异步的方式（用回调）和我们同步的大脑规划行为根本匹配的不是很好。

你能实际想象一下像这样规划你的跑腿 todo 清单的思维线索吗？

> “我得去趟商店，但是我确信在路上我会接到一个电话，于是‘嗨，妈妈’，然后她开始讲话，我会在 GPS 上搜索商店的位置，但那会花几分钟加载，所以我把收音机音量调小以便听到妈妈讲话，
> 然后我发现我忘了穿夹克而且外面很冷，但没关系，继续开车并和妈妈说话，然后安全带警报提醒我要系好，于是‘是的，妈，我系着安全带呢，我总是系着安全带！’。啊，GPS 终于得到方向了，现在...”

虽然作为我们如何度过自己的一天，思考以什么顺序做什么事的规划听起来很荒唐，但这正是我们大脑在功能层面运行的方式。记住，这不是一心多用，而只是快速的环境切换。

我们这些开发者编写异步事件代码困难的原因，特别是当我们只有回调手段可用时，就是意识流思考/计划的流动对我们大多数人是不自然的。

我们用一步接一步的方式思考，但是一旦我们从同步走向异步，在代码中可以用的工具（回调）不是以一步接一步的方式表达的。

而且这就是为什么正确编写和推理使用回调的异步 JS 代码是如此困难：因为它不是我们的大脑进行规划的工作方式。

> [!NOTE]
> 唯一比不知道为什么代码不好用更糟糕的是，从一开始就知道为什么代码好用！这是一种经典的“纸牌屋”心理：“它好用，但不知为什么，所以大家都别碰！”你可能听说过，“他人即地狱”（萨特），而程序员们
> 模仿这种说法，“他人的代码即地狱”。我相信：“不明白我自己的代码才是地狱。”而回调正是肇事者之一。

### 嵌套/链接的回调

考虑下面的代码：

```javascript
listen('click', function handler(evt) {
  setTimeout(function request() {
    ajax('http://some.url.1', function response(text) {
      if (text == 'hello') {
        handler()
      } else if (text == 'world') {
        request()
      }
    })
  }, 500)
})
```

你可能一眼就能认出这样的代码。我们得到了三个嵌套在一起的函数链，每一个函数都代码异步序列（任务，“进程”）的一个步骤。

这样的代码经常被称为“回调地狱（callback hell）”，有时也被称为“末日金字塔（pyramid of doom）”（由于嵌套的缩进使它看起来像一个倒放的三角形）。

但是“回调地狱”实际上与嵌套/缩进几乎无关。它是一个深刻得多的问题。我们将继续在本章剩下的部分看到它为什么和如何成为一个问题。

首先，我们等待“click”事件，然后我们等待定时器触发，然后我们等待 Ajax 应答回来，就在这时它可能会将所有这些再做一遍。

猛的一看，这段代码的异步性质可能看起来与顺序的大脑规划相匹配。

首先（_现在_），我们：

```javascript
listen('..',function handler(..){
  // ..
})
```

_稍后_，我们：

```javascript
setTimeout(function request(..){
  // ..
},500)
```

再*稍后*，我们：

```javascript
ajax('..',function response(..){
  // ..
})
```

最后，（最*稍后*），我们：

```javascript
if(..){
  // ..
}
else {
  // ..
}
```

不过用这样的方式线性推导这段代码有几个问题。
