# :zzz:

[《你不知道的 JavaScript》](https://github.com/ZXheart/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch1.md)

# 异步：现在与将来

在像 JS 这样的语言中最重要但经常被误解的编程技术之一，就是如何表达和操作跨越一段时间的程序行为。

这不仅仅是关于`for`循环开始到`for`循环结束之间发生的事情，当然它确实要花*一些时间*（几微秒到几毫秒）才能完成。它是关于你的程序*现在*运行的部分。和你的程序*稍后*运行的另一部分之间
发生的事情 —— *现在*和*将来*之间有个间隙，在这个间隙中你的程序没有活跃地执行。

几乎所有被编写过的（特别是用 JS）大型程序都不得不用这样或那样的方法来管理这个间隙，不管是等待用户输入，从数据库或文件系统请求数据，通过网络发送数据并等待应答，还是在规定的时间间隔
重复某些任务（比如动画）。在所有这些方法中，你的程序都不得不跨越时间间隙管理状态。就像在伦敦众所周知的一句话（地铁门与月台间的缝隙）：“小心间隙”。

实际上，你程序中*现在*与*将来*的部分之间的联系，就是异步编程的核心。

可以确定的是，异步编程在 JS 的最开始就出现了。但是大多数开发者从没认真的考虑过它到底是如何，为什么出现在他们的程序中的，也没有探索过*其他*处理异步的方式。*足够好*的方法总是老实巴交的
回调函数。今天还有许多人坚持认为回调就绰绰有余了。

但是 JS 在使用范围和复杂性上不停的生长，作为运行在浏览器，服务器何每种可能的设备上的头等编程语言，为了适应它不断扩大的要求，我们在管理异步上感受到的痛苦日趋严重，
人们迫切的需要一种更强大更合理的处理方法。

虽然眼前这一切看起来很抽象，但我保证，随着我们通读这本书你会更完整且坚实的解决它。在接下来的几章中我们将会探索各种异步 JS 编程的新兴技术。

但在接触它们之前，我们将不得不更深刻的理解异步是什么，以及它在 JS 中如何运行。

## 块儿（chunks）中的程序

你可能将你的 JS 程序写在一个 _.js_ 文件中，但几乎可以确定你的程序是由几个代码块儿构成的，仅有其中的一个将会在*现在*执行，而其他的将会在*将来*执行。最常见的*代码块儿*单位是`function`。

大多数刚接触 JS 的开发者都可能会有的问题是，*将来*并不严格且立即的在*现在*之后发生。换句话说，根据定义，*现在*不能完成的任务将会异步的完成，因此我们不会有你可能在直觉上期望或想要的阻塞行为。

考虑这段代码：

```javascript
// ajax(..)是某个包中任意的Ajax函数
var data = ajax('http://some.url.1')

console.log(data)
// 噢！`data`一般不会有Ajax的结果
```

你可能意识到 Ajax 请求不会同步地完成，这意味着`ajax(..)`函数还没有任何返回的值可以赋值给变量`data`。如果`ajax(..)`在应答返回*能够*阻塞，那么`data = ..`赋值将会正常工作。

但那不是我们使用 Ajax 的方式，我们*现在*制造一个异步的 Ajax 请求，直到*将来*我们才会得到结果。

从*现在*“等到”*将来*是简单的（但绝对不是唯一的，或最好的）方法，通常称为回调函数：

```javascript
// ajax(..)是某个包中任意的Ajax函数
ajax('http://some.url.1', function myCallbackFunction(data) {
  console.log(data) // yay, I got my data!
})
```

> [!WARNING]
> 你可能听说过发起同步的 Ajax 请求是可能的。虽然在技术上是这样的，但你永远，永远不应该在任何情况下这样做，因为它将锁定浏览器的 UI（按钮，菜单，滚动条，等等）而且阻止用户与任何东西互动。
> 这是一个非常差劲的主意，你应当永远回避它。

在你提出抗议之前，不，你渴望避免混乱的回调不是使用阻塞的，同步的 Ajax 的正当理由。

举个例子，考虑下面的代码：

```javascript
function now() {
  return 21
}

function later() {
  answer = answer * 2
  console.log('Meaning of life:', answer)
}

var answer = now()

setTimeout(later, 1000) // Meaning of life: 42
```

这个程序中有两个代码块儿：*现在*将会运行的东西，和*将来*将会运行的东西。这两个代码块分别是什么应当十分明显，但还是让我们以最明确的方式指出来

现在：

```javascript
function now() {
  return 21
}

function later() {
  // ..
}

var answer = now()

setTimeout(later, 1000)
```

将来：

```javascript
answer = answer * 2
console.log('Meaning of life:', answer)
```

你的程序一执行，*现在*代码块儿就会立即运行。但`setTimeout(..)`还设置了一个*将来*会发生的事件（一个超时事件），所以`later()`函数的内容将会在一段时间后（从现在开始 1000 毫秒）被执行。

每当你将一部分代码包进`function`并且规定它应当为了响应某些事件而执行（定时器，鼠标点击，Ajax 应答等等），你就创建了一个*将来*代码块儿，也因此在你的程序中引入了异步。

### 异步控制台

关于`console.*`方法如何工作，没有相应的语言规范或一组需求 —— 它们不是 JS 官方的一部分，而是由*宿主环境*添加到 JS 上的（见本丛书的*类型与文法*）。

所以，不同的浏览器和 JS 环境各自为战，这有时会导致令人困惑的行为。

特别的，有些浏览器和某些条件下，`console.log(..)`实际上不会立即输出它得到的东西。这个现象主要原因可能是因为 I/O 处理很慢，而且是许多程序的阻塞部分（不仅是 JS）。所以，对一个浏览器来说，
可能的性能更好的处理方式是（从网页/UI 的角度看），在后台异步的处理`console`I/O，而你也许根本不知道它发生了。

虽然不是很常见，但是一种可能被观察到（不是从代码本身，而是从外部）的场景是：

```javascript
var a = {
  index: 1,
}

// 稍后
console.log(a) // ??

//在稍后
a.index++
```

我们一般希望看到的是，就在`console.log(..)`语句被执行的那一刻，对象`a`被取得一个快照，打印出如`{ index:1 }`的内容，如此在下一个语句`a.index++`执行时，它修改不同于`a`的输出，
或者严格的在`a`的输出之后的某些东西。

大多数时候，上面的代码将会在你的开发者工具控制台中产生一个你期望的对象表现形式。但是同样的代码也可能运行在这样的情况下：浏览器告诉后台它需要推迟控制台 I/O，这时，在对象在控制台中被展示
的那个时间点，`a.index++`已经执行了，所以它将显式`{ index: 2 }`。

到底在什么条件下`console` I/O 将被推迟是不确定的，甚至它能不能被观察到都是不确定的。只能当你在调试过程中遇到问题时 —— 对象在`console.log(..)`语句之后被修改，但你却意外地看
到了修改后的内容 —— 意识到 I/O 的这种可能的异步性。

> [!NOTE]
> 如果你遇到了这种罕见的情况，最好的选择是使用 JS 调试器的断点，而不是依赖`console`的输出。第二好的选择是通过将目标对象序列化为一个`string`强制取得一个它的快照，比如用`JSON.stringify(..)`。

## 事件循环（event loop）

让我们来做一个（也许是令人震惊的）声明：尽管明确的允许异步 JS 代码（就像我们刚看到的`setTimeout`），但是实际上，直到最近（ES6）为止，JS 本身从来没有任何内建的异步概念。

**什么！？**这听起来简直是疯了，对吧？事实上，它是真的。JS 引擎本身除了在某个在被要求的时刻执行你程序的一个单独的代码块外，没有做过任何其他的事情。

“被‘谁’要求”？这才是最重要的部分！

JS 引擎没有运行在隔离的区域。它运行在一个*宿主环境*中，对于大多数开发者来说这个宿主环境就是浏览器。在过去的几年中（但不特指这几年），JS 超越了浏览器的界限进入到了其他环境中，比如服务器，
通过 Node.js 这样的东西。其实，今天 JS 已经被嵌入到所有种类的设备中，从机器人到电灯泡儿。

所有这些环境的一个共同的“线程”（一个“不那么微妙”的异步玩笑，顺便提一下），它们都有一种机制：可以*随着时间的推移*执行你的程序的多个代码块儿，每一时刻都会调用 JS 引擎，这称为“事件循环（event loop）”。

换句话说，JS 引擎对*时间*没有天生的感觉，反而是一个任意 JS 代码段的按需执行环境。是它周围的环境在不停的安排“事件”（JS 代码的执行）。

那么，举例来说，当你的 JS 程序发起一个从服务器取得数据的 Ajax 请求时，你在一个函数（通常称为回调）中建立好“应答”代码，然后 JS 引擎就会告诉宿主环境，“嘿，我就要暂时停止执行了，
但不管你什么时候完成了这个网络请求，而且你还得到一些数据的话，请*回调*这个函数。”

然后浏览器就会为网络的应答设置一个监听器，当它有东西要交给你的时候，它会通过将回调函数插入*事件循环*来安排它的执行。

那么什么是*事件循环*？

让我们先通过一些假想代码来对它形成一个概念：

```javascript
// `event loop`是一个像队列一样的数组（先进先出）
var eventLoop = []
var event

// “永远”执行
while (true) {
  // 执行一个“tick”
  if (eventLoop.length > 0) {
    // 在队列中取得下一个事件
    event = eventLoop.shift()

    // 现在执行下一个事件
    try {
      event()
    } catch (err) {
      reportError(err)
    }
  }
}
```

当然，这只是一个用来展示概念的大幅简化的假想代码。但是对于帮助我们建立更好的理解来说应该够了。

如你所见，有一个通过`while`循环来表现的继续不断的循环，这个循环的每一次迭代称为一个“tick”。在每一个“tick”中，如果队列中有一个事件在等待，它就会被取出执行。这些事件就是你的回调函数。

很重要并需要注意的是，`setTimeout(..)`不会将你的回调放在事件循环队列上。它设置一个定时器；当这个定时器超时的时候，环境才会把你的回调放进事件循环队列，这样在某个未来的“tick”中它将会被取出执行。

如果在那时事件循环队列中已经有了 20 个事件会怎么样？你的回调要等待。它会排到队列最后 —— 没有一般的方法可以插队和跳到队列的最前方。这就解释了为什么`setTimeout(..)`计时器可能不会完美的
按照预计时间触发。你得到一个保证（粗略地说）：你的回调不会在你指定的时间间隔之前被触发，但是可能会在这个时间间隔之后被触发，具体要看事件队列的状态。

换句话说，你的程序通常被打断成许多小的代码块儿，它们一个接一个的在事件循环队列中执行。而且从技术上说，其他与你的程序没有直接关系的事件也可以穿插在队列中。

> [!NOTE]
> 我们提到了“直到最近”，暗示着 ES6 改变了事件循环队列在何处被管理的性质。这主要是一个正式的技术规范，ES6 现在明确地指出了事件循环应当如何工作，这意味着它技术上属于 JS 引擎应当关心的范畴，
> 而不仅仅是*宿主环境*。这么做的一个主要原因是为了引入 ES6 的 Promises（我们将在第三章讨论），因为人们需要有能力对事件循环队列的排队操作进行直接，细粒度的控制（参见“协作”一节中关于`setTimeout(..0)的讨论`）。

## 并行线程

“异步”与“并行”两个词经常被混为一谈，但它们实际上是十分不同的。记住，异步是关于*现在*与*将来*之间的间隙。但并行是关于可以同时发生的事情。

关于并行计算最常见的工具就是进程与线程。进程和线程可以独立执行，也可以同时执行：在不同的处理器上，甚至在不同的计算机上，而多个线程可以共享一个进程的内存资源。

相比之下，一个事件循环将它的工作打碎成一系列任务并串行的执行它们，不允许并行访问和更改共享的内存。并行与“串行”可能以在不同线程上的事件循环协作的形式共存。

并行线程执行的穿插，与异步事件的穿插发生在完全不同的粒度等级上

例如：

```javascript
function later() {
  answer = answer * 2
  console.log('Meaning of life:', answer)
}
```

虽然`later()`的整个内容将被当作一个事件循环队列的实体，但当考虑到将要执行这段代码的线程时，实际上也许会有许多不同的底层操作。比如，`answer = answer * 2`首先需要读取当前`answer`的值，
再把`2`放在某个地方，然后进行乘法计算，最后把结果存回到`answer`。

在一个单线程环境中，线程队列中的内容都是底层操作真的无关紧要，因为没有什么可以打断线程。但如果你有一个并行系统，在同一个程序中有两个不同的线程，你很可能会得到无法预测的行为：

考虑这段代码：

```javascript
var a = 20

function foo() {
  a = a + 1
}

function bar() {
  a = a * 2
}

// ajax(..)是一个给定的库中的随意Ajax函数
ajax('http://some.url.1', foo)
ajax('http://some.url.2', bar)
```

在 JS 的单线程行为下，如果`foo()`在`bar()`之前执行，结果`a`是`42`，但如果`bar()`在`foo()`之前执行，结果`a`将是`41`。

如果 JS 事件共享相同的并行执行数据，问题将会变得微妙得多。考虑这两个假想代码段，它们分别描述了运行`foo()`和`bar()`中代码的线程将要执行的任务，
并考虑如果它们在完全相同的时刻运行会发生什么：

线程 1（`X`和`Y`是临时的内存位置）：

```markdown
foo():
a. 将`a`的值读取到`X`
b. 将`1`存入`Y`
c. 把`X`和`Y`相加，将结果存入`X`
d. 将`X`的值存入`a`
```

线程 2（`X`和`Y`是临时的内存位置）：

```markdown
bar():
a. 将`a`的值读取到`X`
b. 将`2`存入`Y`
c. 把`X`和`Y`相乘，将结果存入`X`
d. 将`X`的值存入`a`
```

现在，让我们假定这两个线程在并行执行。你可能发现了问题，对吧？它们在临时的步骤中使用了共享的内存位置`X`和`Y`。

如果步骤像这样发生，`a`的最终结果是什么？

```markdown
1a 将`a`的值读取到`X` ==> `20`
2a 将`a`的值读取到`X` ==> `20`
1b 将`1`存入`Y` ==> `1`
2b 将`2`存入`Y` ==> `2`
1c 把`X`和`Y`相加，将结果存入`X` ==> `22`
1d 将`X`的值存入`a` ==> `22`
2c 把`X`和`Y`相乘，将结果存入`X` ==> `44`
2d 将`X`的值存入`a` ==> `44`
```

`a`中的结果将是`44`。那么这种顺序呢？

```markdown
1a 将`a`的值读取到`X` ==> `20`
2a 将`a`的值读取到`X` ==> `20`
2b 将`2`存入`Y` ==> `2`
1b 将`1`存入`Y` ==> `1`
2c 把`X`和`Y`相乘，将结果存入`X` ==> `20`
1c 把`X`和`Y`相加，将结果存入`X` ==> `21`
1d 将`X`的值存入`a` ==> `21`
2d 将`X`的值存入`a` ==> `21`
```

`a`的结果将是`21`。

所以，关于线程的编程十分刁钻，因为如果你不采取独特的步骤来防止这样的干扰/穿插，你会得到令人非常诧异的，不确定的行为。这通常让人头疼。

JS 从不跨线程共享数据，这意味着不必关心这一层的不确定性。但这并不意味着 JS 总是确定性的。记得前面的`foo()`和`bar()`的相对顺寻产生两个不同的结果吗（`41`或`42`）？

> [!NOTE]
> 可能还不明显，但不是所有的不确定性都是坏的。有时候它无关紧要，有时候它是故意的。我们会在本章和后续几章中看到更多的例子。

### 运行至完成

因为 JS 是单线程的，`foo()`和`bar()`中的代码是原子性[^atomicity]的，这意味着一旦`foo()`开始运行，它的全部代码都会在`bar()`中的任何代码可以运行之前执行完成，反之亦然。这称为“运行至完成”行为。

事实上，运行至完成的语义会在`foo()`与`bar()`中有更多的代码时更明显，比如：

```javascript
var a = 1
var b = 2

function foo() {
  a++
  b = b * a
  a = b + 3
}

function bar() {
  b--
  a = 8 + b
  b = a * 2
}

// ajax(..)是某个库中的随意的Ajax函数
ajax('http://some.url.1', foo)
ajax('http://some.url.2', bar)
```

因为`foo()`不能被`bar()`打断，而且`bar()`不能被`foo()`打断，所以这个程序根据哪一个先执行只有两种可能的结果 —— 如果线程存在，`foo()`和`bar()`中的每一个语句都可能被穿插，可能的结果数量将会极大的增长！

代码块儿 1 是同步的（*现在*发生），但代码块儿 2 和 3 是异步的（*将来*发生），这意味着它们的执行将会被时间的间隙分开。

代码块儿 1：

```javascript
var a = 1
var b = 2
```

代码块儿 2：

```javascript
a++
b = b * a
a = b + 3
```

代码块儿 3：

```javascript
b--
a = 8 + b
b = a * 2
```

代码块儿 2 和 3 哪一个都有可能先执行，所以这个程序有两个可能的结果，正如这里展示的：

结果 1：

```javascript
var a = 1
var b = 2

// foo()
a++
b = b * a
a = b + 3

// bar()
b--
b = 8 + b
b = a * 2

a // 11
b //22
```

结果 2：

```javascript
var a = 1
var b = 2

// bar()
b--
b = 8 + b
b = a * 2

// foo()
a++
b = b * a
a = b + 3

a // 183
b // 180
```

同一段代码有两种结果仍然意味着不确定性！但是这是在函数（事件）顺序的水平上，而不是在使用线程时语句顺序的水平上（或者说，实际上是表达式操作的顺序上）。换句话说，它比线程更具有*确定性*。

当套用到 JS 行为时，这种函数顺序的不确定性通常称为“竞合状态”，因为`foo()`和`bar()`在互相竞争看谁会先执行。明确的说，它是一个“竞合状态”因为你不能可靠的预测`a`与`b`将如何产生。

> [!NOTE]
> 如果在 JS 中不知怎的有一个函数没有运行至完成的行为，我们会有更多可能的结果，对吧？ES6 中引入一个这样的东西（见第四章“生成器”），但现在不要担心，我们会回头讨论它。

## 并发

让我们想象一个网站，它显示一个随着用户向下滚动而逐步加载的状态更新列表（就像社交网络的新消息）。要使这样的特性正常工作，（至少）需要两个分离的“进程”*同时*执行（在同一个时间跨度内，但没必要是同一个时间点）。

> [!NOTE]
> 我们在这里使用带引号的“进程”，因为它们不是计算机科学意义上的真正的操作系统级别的进程。它们是虚拟进程，或者说任务，表示一组逻辑上关联，串行顺序的操作。我们将简单的使用“进程”而非“任务‘，
> 因为在术语层面它与我们讨论的概念的定义相匹配。

第一个“进程”将响应当用户向下滚动页面时触发的`onscroll`事件（发起取得新内容的 Ajax 请求）。第二个“进程”将接收返回的 Ajax 应答（将内容绘制在页面上）。

显然，如果用户向下滚动的足够快，你也许会看到在第一个应答返回并处理期间，有两个或更多的`onscroll`事件被触发，因此你将使`onscroll`事件和 Ajax 应答事件迅速触发，互相穿插在一起。

并发是当两个或多个“进程”在同一时间段内同时执行，无论构成它们的各个操作是否*并行的*（在同一时刻不同的处理器或内核）发生。你可以认为并发是“进程”级别的（或任务级别的）的并行机制，而不是操作级别的并行机制（分割进程的线程）。

> [!NOTE]
> 并发还引入了这些“进程”间彼此互动的概念。我们稍后会讨论它。

在一个给定的时间跨度内（用户可以滚动的那几秒），让我们将每个独立的“进程”作为一系列事件/操作描绘出来：

“线程”1（`onscroll`事件）：

```markdown
onscroll, request 1
onscroll, request 2
onscroll, request 3
onscroll, request 4
onscroll, request 5
onscroll, request 6
onscroll, request 7
```

“线程”2（Ajax 应答事件）：

```markdown
response 1
response 2
response 3
response 4
response 5
response 6
response 7
```

一个`onscroll`事件与一个 Ajax 应答事件很有可能在同一个*时刻*都准备好被处理了。比如我们在一个时间线上描绘一下这些事件的话：

```markdown
onscroll, request 1
onscroll, request 2 response 1
onscroll, request 3 response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6 response 4
onscroll, request 7
response 5
response 6
response 7
```

但是，回到本章前面的事件循环概念，JS 一次只能处理一个事件，所以不是`onscroll, request 2`首先发生就是`response 1`首先发生，但是它们不可能在同一时刻发生。
就像学校食堂的孩子们，不管他们在门口挤成什么样，他们最后都不得不排成一个队来打饭！

让我们来描绘一下所有这些时间在事件循环队列上穿插的情况：

事件循环队列：

<!-- prettier-ignore -->
```markdown
onscroll, request 1 <-- 进程1开始
onscroll, request 2 
response 1          <-- 进程2开始
onscroll, request 3 
response 2
response 3
onscroll, request 4
onscroll, request 5
onscroll, request 6 
response 4
onscroll, request 7 <-- 进程1结束
response 6
response 5
response 7          <-- 进程2结束
```

“进程 1”和“进程 2”并发的运行（任务级别的并行），但是它们的个别事件在事件循环队列上顺序的运行。

顺便说一句，注意到`response 6`和`response 5`没有按照预想的顺序应答吗？

单线程事件循环是并发的一种表达（当然还有其他的表达，我们稍后讨论）。

### 非互动

[^atomicity]: [原子性](https://zh.wikipedia.org/wiki/ACID)
