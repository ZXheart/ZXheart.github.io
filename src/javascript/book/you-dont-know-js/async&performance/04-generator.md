# :zzz:

[《你不知道的 JavaScript》](https://github.com/ZXheart/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/ch4.md)

# generator

在第二章中，我们发现了在使用回调表达异步流程控制时的两个关键缺陷：

- 基于回调的异步不符合大脑对任务步骤的规划方式
- 由于*控制反转*，回调并不是可信任或可组合的

在第三章中，我们详细介绍了 Promise 如何把回调的*控制反转*再反转回来，恢复了可信任性/可组合性。

现在我们把注意力转移到一种顺序、看似同步的异步流程控制表达风格。使这种风格成为可能“魔法”就是 ES6 生成器（generator）。

## 打破完整运行

在第一章中，我们解释了 JS 开发者在代码中几乎普遍依赖的一个假定：一个函数一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。

可能看起来似乎有点奇怪，不过 ES6 引入了一个新的函数类型，它并不符合这种运行到结束的特性。这类新的函数被称为生成器。

考虑如下这个例子来了解其含义：

```javascript
var x = 1

function foo() {
  x++
  bar() // 这一行是什么作用？

  console.log('x:', x)
}

function bar() {
  x++
}
foo() // x: 3
```

在这个例子中，我们确信`bar()`会在`x++`和`console.log(x)`之间运行。但是，如果`bar()`并不在那里会怎样呢？显然结果就会是 2，而不是 3。

现在动脑筋想一下。如果`bar()`并不在那儿，但出于某种原因它仍然可以在`x++`和`console.log(x)`与句之间运行，这又会怎样呢？这如何才会成为可能呢？

如果是在抢占式多线程语言中，从本质上说，这是可能发生的，`bar()`可以在两个语句之间打断并运行。但 JS 并不是抢占式的，（目前）也不是多线程的。然而，如果`foo()`自身可以通过
某种形式在代码的这个位置指示暂停的话，那就仍然可以以一种合作式的方式实现这样的中断（并发）。

> [!NOTE]
> 这里我之所以使用了“合作式的”一次，不只是因为这与经典并发术语之间的关联（参见第一章）；还因为你将会在下一段代码中看到的，ES6 代码中指示暂停点的语法是`yield`,
> 这也礼貌的表达了一种合作式的控制放弃。

下面是实现这样的合作式并发的 ES6 代码：

```javascript
var x = 1

function* foo() {
  x++
  yield
  console.log('x:', x)
}

function bar() {
  x++
}
```

> [!NOTE]
> 很可能你看到的其他多数 JS 文档和代码中的生成器声明格式都是`function* foo(){ .. }`，而不是我这里是用的`function *foo(){ .. }`：唯一区别是`*`位置的风格不同。这两种形式在
> 功能和语法上都是等同的，还有一种是`function*foo(){ .. }`（没有空格）也一样。两种风格，各有优缺，但总体上我比较喜欢`function *foo(){ .. }`的形式，因为这样在使用`*foo()`
> 来引用生成器的时候就会比较一致。如果只用`foo()`的形式，你就不会清楚知道我指的是生成器还是常规函数。这完全是一个风格偏好问题。

现在，我们要如何运行前面的代码片段，使得`bar()`在`*foo()`内部的`yield`处执行呢？

```javascript
// 构建一个迭代器it来控制这个生成器
var it = foo()

// 这里启动foo()!
it.next()
// x: 2
bar()
// x: 3
it.next() // x: 3
```

好吧，这两段代码中有很多新知识，可能会让人迷惑，所以这里有很多东西需要学习。在解释 ES6 生成器的不同机制和语法之前，我们先来看看运行过程。

1. `it = foo()`运算并没有执行生成器`*foo()`，而只是构造了一个*迭代器（iterator）*，这个迭代器会控制它的执行。后面会介绍迭代器。

2. 第一个`it.next()`启动了生成器`*foo()`，并运行了`*foo()`的第一行`x++`。

3. `*foo()`在`yield`语句处暂停，在这一点上第一个`it.next()`调用结束。此时`*foo()`仍然在运行并且是活跃的，但处于暂停状态。

4. 我们查看`x`的值，此时为 2。

5. 我们调用`bar()`，它通过`x++`再次递增 `x`。

6. 我们再次查看`x`的值，此时为 3。

7. 最后的`it.next()`调用从暂停处恢复了生成器`*foo()`的执行，并运行了`console.log(..)`语句，这条语句使用当前`x`的值 3。

显然，`foo()`启动了，但是没有完全运行，它在`yield`处暂停了。后面恢复了`foo()`并让它运行到结束，但这不是必须的。

因此，生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非的要完成。尽管现在还不是特别清楚它的强大之处，但随着对本章后续内容的深入学习，我们会看到
它将成为用于构建以生成器作为异步流程控制的代码模式的基础构件之一。

### 输入和输出

生成器函数是一个特殊的函数，具有前面我们展示的新的执行模式。但是，它仍然是一个函数，这意味着它仍然有一些基本的特性没有改变。比如，它仍然可以接受参数（即输入），
也能够返回值（即输入）。

```javascript
function* foo(x, y) {
  return x * y
}

var it = foo(6, 7)
var res = it.next()
console.log(res.value) // 42
```

我们向`*foo()`传入实参 6 和 7 分别作为参数`x`和`y`。`*foo()`向调用代码返回 42。

现在我们可以看到生成器和普通函数在调用上的一个区别。显然`foo(6, 7)`看起来很熟悉。但难以理解的是，生成器`*foo(..)`并没有像普通函数一样实际运行。

事实上我们只是创建了一个迭代器对象，把它赋给了一个变量`it`，用于控制生成器`*foo(..)`。然后调用`it.next()`，只是生成器`*foo(..)`从当前位置开始继续运行，停在下一个`yield`处
或者直到生成器结束。

这个`next(..)`调用的结果是一个对象，它有一个`value`属性，持有从`*foo(..)`返回的值（如果有的话）。换句话说，`yield`会导致生成器在执行过程中发送出一个值，这有点类似于中间的`return`。

目前还不清楚为什么需要这一整个间接迭代器对象来控制生成器。会清楚的，我保证。

#### 迭代消息传递

除了能够接受参数并提供返回值之外，生成器甚至提供了更强大更引人注目的内建消息输入输出能力，通过`yield`和`next(..)`实现。

考虑：

```javascript
function* foo(x) {
  var y = x * (yield)

  return y
}

var it = foo(6)

// 启动foo(..)
it.next()

var res = it.next(7)

res.value // 42
```

首先，传入 6 作为参数`x`。然后调用`it.next()`，这会启动`*foo()`。

在`*foo()`内部，开始执行语句`var y = x ..`，但随后就遇到了一个`yield`表达式。它就会在这一点上暂停`*foo(..)`（在赋值语句中间！），并在本质上要求调用代码为`yield`表达式提供一个
结果值。接下来，调用`it.next(7)`，这一句把值`7`传回作为被暂停的`yield`表达式的结果。

所以，这时赋值语句实际上就是`var y = 6 * 7`。现在，`return y`返回值 42 作为调用`it.next(7)`的结果。

注意，这里有一点非常重要，但即使对于有经验的 JS 开发者也很有迷惑性：根据你的视角不同，`yield`和`next(..)`调用有一个不配。一般来说，需要的`next(..)`调用要比`yield`语句
多一个，前面的代码片段有一个`yield`和两个`next(..)`调用。

为什么会有这个不匹配？

因为第一个`next(..)`总是启动一个生成器，并运行到第一个`yield`处。不过，是第二个`next(..)`调用完成第一个被暂停的`yield`表达式，第三个`next(..)`调用完成第二个`yield`，以此类推。

#### 两个问题的故事

实际上，你主要考虑的是哪部分代码会影响你是否感知到错位。
