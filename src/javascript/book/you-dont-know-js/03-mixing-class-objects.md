# :zzz:

[《你不知道的 JavaScript》](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch4.md)

## 类理论

“类/继承”描述了一种特定的代码组织和结构形式 —— 一种在我们的软件中对真实世界的建模方法。

OO 或面向类的编程强调数据和操作它的行为之间有固有的联系（当然，依数据的类型和性质不同而不同！），所以合理的设计是将数据和行为打包在一起（也
称为封装）。这有时在正式的计算机科学中称为“数据结构”。

比如，表示一个单词或短语的一系列字符通常称为“string（字符串）”。这些字符就是数据。但你几乎从来不关心数据，你总是想对数据*做事情*，所以可以
*向*数据实施的行为（计算它的长度，在末尾添加数据，检索，等等）都被设计成`String`类的方法。

任何给定的字符串都是这个类的一个实例，这个类是一个整齐的集合包装：字符数据和我们可以对它进行操作的功能。

类还隐含着一个对一个特定数据结构的一种*分类*方法。其做法是将一个给定的解构考虑为一个更加泛化的基础定义的具体种类。

让我们通过一个最常被引用的例子来探索这种分类处理。一辆*车*可以被描述为一“类”更泛化的东西 —— 载具 —— 的具体实现。

我们在软件中通过定义`Vehicle`类和`Car`类来模型化这种关系。

`Vehicle`的定义可能会包含像动力（引擎等），载人能力等等，这些都是行为。我们在`Vehicle`中定义的都是所有（或大多数）不同类型的载具（飞机、火车
、机动车）都共同拥有的东西。

在我们的软件中为每一种不同类型的载具一次又一次地重定义“载人能力”这个基本性质可能没有道理。反而，我们在`Vehicle`中把这个能力定义一次，之后当
我们定义`Car`时，我们简单地指出它从基本的`Vehicle`定义中“继承”（或“扩展”）。于是`Car`的定义就被称为特化了更一般的`Vehicle`定义。

`Vehicle`和`Car`用方法的形式集约地定义了行为，另一方面一个实例中的数据就像一个唯一的车牌号一样属于一辆具体的车。

**这样，类，继承，实例化就诞生了**

另一个关于类的关键概念是`多态（polymorphism）`，它描述这样的想法：一个来自于父类的泛化行为可以被字类覆盖，从而使它更加具体。实际上，相对多态
允许我们在覆盖行为中引用基础行为。

类理论强调建议父类和子类对相同行为共享同样的方法名，以便子类（差异化地）覆盖父类。我们即将看到，在你的 JS 代码中这么做会导致种种困难和脆弱的
代码。

### 类设计模式

你可能从没把类当作一种“设计模式”考虑过，因为最常见的是关于流行的“面向对象设计模式”的讨论，比如“迭代器（Iterator）”、“观察者（Observer）”、 “
工厂（Factory）”、“ 单例（Singleton）”等等。当以这种方式表现时，几乎可以假定 OO 的类是我们实现所有（高级）设计模式的底层机制 l，好像对所有代
码来说 OO 是一个给定的基础。

取决于你在编程方面接受过的正规教育的水平，你可能听过“过程式编程（procedural programming）”：一种不用任何高级抽象，仅仅由过程（也就是函数）调
用其它函数构成的描述代码的方式。你可能被告知过，类是一个将过程式风格“面条代码”转换为结构良好，组织良好代码的*恰当*的方法。

当然，如果你有“函数式编程（functional programming）”的经验，你可能知道类只是几种常见设计模式中的一种。但是对于其他人来说，这可能是第一次你问
自己，类是否真的是代码的根本基础，或者它们是在代码顶层上的选择性抽象。

有些语言（比如 Java）不给你选择，所以这根本没什么*选择性* —— 一切都是类。其他语言如 C/C++或 PHP 同时给你过程式和面向类的语法，所以你可以选择
。

### JavaScript 的类

JS 拥有*一些*像类的语法元素（比如`new`和`instanceof`）有一阵子了，ES6 中还追加了`class`关键字。

但这**并没有**意味着 JS 有类。

由于类是一种设计模式，你*可以*，用相当的努力（正如本章接下来的部分），近似实现很多经典类的功能。JS 在通过提供看起来像类的语法，来努力满足用
类进行设计的的极其广泛的*渴望*。

虽然我们有了看起来像类的语法，但是 JS 机制好像在抵制你使用*类设计模式*，因为在底层，这些你正在上边工作的机制运行的十分不同。语法糖和（极其广
泛使用的）JS “Class” 库废了很大力气来把这些真实情况对你隐藏起来，但你迟早会面对现实：你在其他语言中遇到的*类*和你在 JS 中模拟的*类*不同。

总而言之，类是软件设计中的一种可选模式，你可以选择 JS 中使用或不使用它。因为许多开发者对面向类的软件设计情有独钟，本章剩下部分探索一下，为了
使用 JS 提供的东西维护类的幻觉要付出什么代价，和我们经历的痛苦。

## 类机制

在许多面向类语言中，“标准库”都提供一个叫“栈”（压栈，弹出等）的数据结构，用一个`Stack`类表示。这个类拥有一组变量来存储数据，还拥有一组可公开
访问的行为（“方法”），这些行为使你的代码有能力与（隐藏的）数据互动（添加或移除数据等等）。

但是在这样的语言中，你不是直接在`Stack`上操作（除非制造一个**静态的**类成员引用，但这超出了讨论范围）。`Stack`类仅仅是*任何*的“栈”都会做的事
情的一个抽象解释，但它本身不是一个“栈”。为了得到一个可以对之进行操作的实在的数据结构，你必须**实例化**这个`Stack`类。

### 建筑物

传统的“类（class）”和“实例（instance）”得比拟源自于建筑物的建造。

一个建筑师会规划一栋建筑的所有性质：宽、高、在哪里有多少窗户、甚至墙壁和天花板用什么材料。在这个时候，她并不关心建筑物将会被建造在*哪里*，也
不关心有*多少*这栋建筑的拷贝将被建造。

同时她也不关心这栋建筑的内容 —— 家具、墙纸、吊扇等等 —— 她仅关心建筑物含有何种结构。

她生产的建筑学上的蓝图仅仅是建筑物的“方案”。它们不实际构成我们可以实在进入其中并坐下的建筑物。为了这个任务我们需要一个建筑工人。建筑工人会拿
走方案并精确地依照它们*建造*这栋建筑物。在真正的意义上，他是在将方案中意图的性质*拷贝*到物理建筑物中。

一旦完成，这栋建筑就是蓝图方案的一个物理实例，一个很可能实质完美的*拷贝*。然后建筑工人就可以移动到隔壁将它在重做一遍，建造另一个*拷贝*。

建筑物与蓝图间的关系是间接的。你可以检视蓝图来了解建筑物是如何构造的，但对于直接考察建筑物的每一部分，仅有蓝图是不够的。如果你想打开一扇门，
你不得不走进建筑物本身 —— 蓝图仅仅是为了用来*表示*门的位置而在纸上画的线条。

一个类就是一个蓝图。为了实际得到一个对象并与之互动，我们必须从类中建造（也就是实例化）某样东西。这种“建造”的最终结果是一个对像，通常称为一个
“实例”，我们可以按需要直接调用它的方法，访问它的公共数据属性。

**这个对象是所有在类中被描述的特性的*拷贝*。**

你不太可能会指望走进一栋建筑之后发现，一份用于规划这栋建筑物的蓝图被裱起来挂在墙上，虽然蓝图可能在办公室的公共记录的文件中。相似地，你一般不
会使用对象实例来直接访问和操作类，但是对于判定对象实例来自于*哪个类*至少是可能的。

与考虑对象实例与它源自的类的任何间接关系相比，考虑类和对象实例的直接关系更有用。**一个类通过拷贝操作被实例化为对象的形式。**

### 构造器（constructor）

类的实例由类的一种特殊方法构建，这个方法的名称通常与类名相同，称为“构造器（constructor）”。这个方法的具体工作，就是初始化实例所需的所有信息
（状态）。

比如，考虑下面这个类的假想代码（语法是自创的）：

```javascript
class CoolGuy {
  specialTrick = nothing
  CoolGuy(trick) {
    specialTrick = trick
  }
  showOff() {
    output("Here's my trick: ", specialTrick)
  }
}
```

为了*制造*一个`CoolGuy`实例，我们需要调用类的构造器：

```javascript
Joe = new CoolGuy('jumping rope')

Joe.showOff() // Here's my trick: jumping rope
```

`CoolGuy`类有一个构造器`CoolGuy`，它实际上就是在我们`new CoolGuy(..)`时调用的。我们从这个构造器拿回一个对象（类的一个实例），我们可以调
用`showOff()`方法，来打印这个特定的`CoolGuy`的特殊才艺。

类的构造器*属于*哪个类，几乎总是和类同名。同时，构造器大多数情况下总是需要用`new`来调用，以便使语言的引擎知道你想要构建一个*新的*类的实例。

### 类继承

在面向类的语言中，你不仅可以定义一个能够初始化它自己的类，你还可以定义另一个类**继承**自第一个类。

这第二个类通常被称为“字类”，而第一个类被称为“父类”。这些名词显然来自于亲子关系的比拟，虽然这种比拟有些扭曲，就像你马上要看到的。

当一个家长拥有一个和他有血缘关系的孩子时，家长的遗传性质会被拷贝到孩子身上。明显地，在大多数生物繁殖系统中，双亲都平等地贡献基因进行混合。但
是为了这个比拟的目的，我们假设只有一个亲人。

一旦孩子出现，他或她就从亲人那里分离出来。这个孩子受其亲人的继承因素的严重影响，但是独一无二。如果这个孩子拥有红色头发（玛莲妮亚？），这并不
意味着他的亲人的头发*曾经*是红色，或者自动*变成*红色。

以相似的方式，一旦一个子类被定义，它就分离且区别于父类。子类含有一份从父类那里得来的行为的初始拷贝，但它可以覆盖这些继承的行为，甚至是定义新
行为。

重要的是，要记住我们是在讨论父**类**和子**类**，而不是物理上的东西。这就是这个亲子比拟让人糊涂的地方，因此我们实际上应当说父类就是亲人的
DNA，而子类就是孩子的 DNA。我们不得不从两套 DNA 制造出（也就是“初始化”）人，用得到的物理上存在的人来与之进行谈话。

让我们把生物学上的亲自放到一边，通过一个稍稍不同的角度来看看继承：不同种类的载具。这是用来理解继承的最经典（也是争议不断）的比拟。
