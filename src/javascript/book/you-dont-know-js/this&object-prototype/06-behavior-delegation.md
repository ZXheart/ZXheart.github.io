# :zzz:

[《你不知道的 JavaScript》](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch6.md)

# 行为委托

在第五章中，我们详细讨论了`[[Prototype]]`机制，和*为什么*对于描述“类”或“继承”来说它是那么使人糊涂和不合适。我们一路跋涉
，不仅涉及了相当繁冗的语法（是代码凌乱的`.prototype`），还有各种陷阱（比如使人吃惊的`.constructor`解析和难看的假想多态语
法）。我们探索了许多人试图用抹平这些粗糙的区域而使用的各种“mixin”方法。

我希望到现在你不会甘心于敷衍了事并把这样的细节丢给一个“黑盒”库。我们现在来深入讲解我们*如何与应当如何*以一种比类造成的困
惑*简单得多而且更直接的方式*来考虑 JS 中对象的`[[Prototype]]机制`。

简单地复习一下第五章的结论，`[[Prototype]]`机制是一种存在于一个对象上的内部链接，它指向一个其他对象。

当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，`[[Prototype]]`链接
告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的`[[Prototype]]`查询，如此继续
。这种对象间的一系列链接构成了所谓的“原型链”。

换句话说，对于我们能在 JS 中利用的功能的实际机制来说，其重要的实质**全部在于被链接到其他对象的对象**。

这个观点是理解本章其余部分的动机和方法的重要基础！

## 迈向面向委托的设计

为了将我们的思想恰当地集中在如何用最直截了当的方法使用`[[Prototype]]`，我们必须认识到它代表一种根本上与类不同的设计模式
（见第四章）。

::: tip

*某些*面向类的设计依然是很有效的，所以不要扔掉你知道的每一件事（扔掉大多数就行了！）。比如，*封装*就十分强大，而且与委托
是兼容的（虽然不那么常见）。

:::

我们需要试着将我们的思维从类/继承的设计模式转变为行为代理设计模式。如果你已经使用你在教育/工作生涯中思考类的方式做了大多
数或所有的编程工作，这可能感觉不舒服或不自然。你可能需要尝试这种思维过程好几次，才能适应这种非常不同的思考方式。

我将首先带你进行一些理论练习，之后我们会一对一地看一些更实际的例子来为你自己的代码提供实践环境。

### 类理论

比方说我们有一个相似的任务（“XYZ”，“ABC”，等等）需要在我们的软件中建模。

使用类，你设计这个场景的方式是：定义一个泛化的父类（基类）比如`Task`，为所有的“同类”任务定义共享的行为。然后，你定义子
类`XYZ`和`ABC`，它们都继承自`Task`，每个都分别添加了特化的行为来处理各自的任务。

**重要的是**，类设计模式将鼓励你发挥继承的最大功效，当你在`XYZ`任务中覆盖`Task`的某些泛化方法的定义时，你将会想利用方法
覆盖（和多态），也许会利用`super`来调用这个方法的泛化版本，为它添加更多的行为。**你很可能会找到几个这样的地方：可以“抽象
”到父类中，并在子类中特化（覆盖）的一般化行为**。

这是一些关于这个场景的假想代码：

```javascript
class Task {
  id
  // `Task()` 构造器
  Task(ID) {
    id = ID
  }
  outputTask() {
    output(id)
  }
}
class XYZ inherits Task{
    label
    // `XYZ()` 构造器
    XYZ(ID, Label) {
        super(ID)
        label = Label
    }
    outputTask() {
        super()
        output(label)
    }
}
class ABC inherits Task{
    // ...
}
```

现在，你可以初始化一个或多个`XYZ`子类的**拷贝**，并且使用这些实例来执行`XYZ`任务。这些实例已经**同时拷贝**了泛化
的`Task`定义的行为和具体的`XYZ`定义的行为。类似地，`ABC`类的实例将拷贝`Task`的行为和具体的`ABC`的行为。在构建完成之后，
你通常仅会与这些实例交互（而不是类），因为每个实例都拷贝了完成计划任务的所有行为。

### 委托理论

但是现在让我们试着用*行为委托*代替*类*来思考同样的问题。

你将首先定义一个称为`Task`的**对象**（不是一个类，也不是一个大多数 JS 开发者想让你相信的`function`），而且它将拥有具体的
行为，这些行为包含各种任务可以使用的（读作：委托至！）工具方法。然后，对于每个任务（“XYZ”，“ABC”），你定义一个**对象**来
持有这个特定人物的数据/行为。你**链接**你的特定任务对象到`Task`工具对象，允许它们在必要的时候可以委托到它。

基本上，你认为执行任务“XYZ”就是从两个兄弟/对等的对象，（`XYZ`和`Task`）中请求行为来完成它。与其通过类的拷贝将它们组合在
一起，我们可以将它们保持在分离的对象中，而且可以在需要的情况下允许`XYZ`对象**委托到**`Task`对象。

这里是一些简单的代码，示意你如何实现它：

```javascript
var Task = {
  setID: function (ID) {
    this.id = ID
  },
  outputID: function () {
    console.log(this.id)
  },
}
// 使 `XYZ` 委托至 `Task`
var XYZ = Object.create(Task)

XYZ.prepareTask = function (ID, Label) {
  this.setID(ID)
  this.label = Label
}
XYZ.outputTaskDetails = function () {
  this.outputID()
  console.log(this.label)
}

// ABC = Object.create(Task)
// ABC ... = ...
```

在这段代码中，`Task`和`XYZ`不是类（也不是函数），它们**仅仅是对象**。`XYZ`通过`Object.create()`创建，来`[[Prototype]]`委
托到`Task`对象。

作为与面向类（也就是，OO —— object oriented）的对比，我称这种风格的代码为“OLOO”（object linked to other objects（链接到
其他对象的对象））。所有我们*真正*关心的是，对象`XYZ`委托到对象`Task`（对象`ABC`也一样）。

在 JS 中，`[[Prototype]]`机制将**对象**链接到其他**对象**。无论你多么想说服自己这不是真的，JS 没有像“类”那样的抽象机制。
这就像逆水行舟：你*可以*做到，但你*选择*了逆流而上，所以很明显地，**你会更困难达到目的地**。

**OLOO 风格的代码**中有一些需要注意的不同：

1. 前一个类的例子中的`id`和`label`数据成员都是`XYZ`上的直接数据属性（它们都不在`Task`上）。一般来说，当`[[Prototype]]`委
   托引入时，**你想使状态保持在委托者上**（`XYZ`，`ABC`），不是在委托上（`Task`）。

2. 在类的设计模式中，我们故意在父类（`Task`）和子类（`XYZ`）上采用相同的命名`outputTask`，以至于我们可以利用覆盖（多态）
   。在委托的行为中，我们反其道而行之：**我们尽一切可能避免在[[Prototype]]链的不同层级上给出相同的命名**（称为“遮蔽”——见
   第五章），因为这些命名冲突会导致尴尬/脆弱的语法来消除引用的歧义（见第四章），而我们想避免它。这种设计模式不那么要求那
   些倾向于被覆盖的泛化的方法名，而是要求针对每个对象的*具体*行为类型给出更具描述性的方法名。**这实际上会产生更容易理解/
   维护的代码**，因为方法名（不仅在定义的位置，而是扩散到其他代码中）变得更加明白（代码即文档）。

3. `this.setID(ID);`位于对象`XYZ`的一个方法内部，它首先在`XYZ`上查找`setID(..)`，但因为它不能在`XYZ`上找到这个名称的方法
   ，`[[Prototype]]`委托意味着它可以沿着链接到`Task`来寻找`setID()`，这样当然就能找到了。另外，由于调用点的隐含`this`绑
   定规则（见第二张），当`setID()`运行时，即便方法是在`Task`上找到的，这个函数调用的`this`绑定依然是我们期望和想要
   的`XYZ`。我们在代码稍后的`this.outputID()`中也看到了同样的事情。换句话说，我们可以使用存在于`Task`上的泛化工具
   与`XYZ`互动，因为`XYZ`可以委托至`Task`。
