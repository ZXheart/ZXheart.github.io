# :zzz:

[《你不知道的 JavaScript》](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch6.md)

# 行为委托

在第五章中，我们详细讨论了`[[Prototype]]`机制，和*为什么*对于描述“类”或“继承”来说它是那么使人糊涂和不合适。我们一路跋涉
，不仅涉及了相当繁冗的语法（是代码凌乱的`.prototype`），还有各种陷阱（比如使人吃惊的`.constructor`解析和难看的假想多态语
法）。我们探索了许多人试图用抹平这些粗糙的区域而使用的各种“mixin”方法。

我希望到现在你不会甘心于敷衍了事并把这样的细节丢给一个“黑盒”库。我们现在来深入讲解我们*如何与应当如何*以一种比类造成的困
惑*简单得多而且更直接的方式*来考虑 JS 中对象的`[[Prototype]]机制`。

简单地复习一下第五章的结论，`[[Prototype]]`机制是一种存在于一个对象上的内部链接，它指向一个其他对象。

当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，`[[Prototype]]`链接
告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的`[[Prototype]]`查询，如此继续
。这种对象间的一系列链接构成了所谓的“原型链”。

换句话说，对于我们能在 JS 中利用的功能的实际机制来说，其重要的实质**全部在于被链接到其他对象的对象**。

这个观点是理解本章其余部分的动机和方法的重要基础！

## 迈向面向委托的设计

为了将我们的思想恰当地集中在如何用最直截了当的方法使用`[[Prototype]]`，我们必须认识到它代表一种根本上与类不同的设计模式
（见第四章）。

::: tip

*某些*面向类的设计依然是很有效的，所以不要扔掉你知道的每一件事（扔掉大多数就行了！）。比如，*封装*就十分强大，而且与委托
是兼容的（虽然不那么常见）。

:::

我们需要试着将我们的思维从类/继承的设计模式转变为行为代理设计模式。如果你已经使用你在教育/工作生涯中思考类的方式做了大多
数或所有的编程工作，这可能感觉不舒服或不自然。你可能需要尝试这种思维过程好几次，才能适应这种非常不同的思考方式。

我将首先带你进行一些理论练习，之后我们会一对一地看一些更实际的例子来为你自己的代码提供实践环境。

### 类理论

比方说我们有一个相似的任务（“XYZ”，“ABC”，等等）需要在我们的软件中建模。

使用类，你设计这个场景的方式是：定义一个泛化的父类（基类）比如`Task`，为所有的“同类”任务定义共享的行为。然后，你定义子
类`XYZ`和`ABC`，它们都继承自`Task`，每个都分别添加了特化的行为来处理各自的任务。

**重要的是**，类设计模式将鼓励你发挥继承的最大功效，当你在`XYZ`任务中覆盖`Task`的某些泛化方法的定义时，你将会想利用方法
覆盖（和多态），也许会利用`super`来调用这个方法的泛化版本，为它添加更多的行为。**你很可能会找到几个这样的地方：可以“抽象
”到父类中，并在子类中特化（覆盖）的一般化行为**。

这是一些关于这个场景的假想代码：

```javascript
class Task {
  id
  // `Task()` 构造器
  Task(ID) {
    id = ID
  }
  outputTask() {
    output(id)
  }
}
class XYZ inherits Task{
    label
    // `XYZ()` 构造器
    XYZ(ID, Label) {
        super(ID)
        label = Label
    }
    outputTask() {
        super()
        output(label)
    }
}
class ABC inherits Task{
    // ...
}
```

现在，你可以初始化一个或多个`XYZ`子类的**拷贝**，并且使用这些实例来执行`XYZ`任务。这些实例已经**同时拷贝**了泛化
的`Task`定义的行为和具体的`XYZ`定义的行为。类似地，`ABC`类的实例将拷贝`Task`的行为和具体的`ABC`的行为。在构建完成之后，
你通常仅会与这些实例交互（而不是类），因为每个实例都拷贝了完成计划任务的所有行为。
