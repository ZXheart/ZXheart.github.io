# :zzz:

[《你不知道的 JavaScript》](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/types%20%26%20grammar/ch5.md)

# 文法

我们想要解决的最后一个主要话题是 JS 的语法如何工作（也称为它的文法）。你可能认为你懂得如何编写 JS，但是语言文法的各个部分中有太多微妙地方导致了困惑和误解，所以我们想要深入这些部分并搞清楚一些事情。

> [!NOTE]
> 对于读者们来说，“文法（grammar）”一词不像“语法（syntax）”一词那么为人熟知。在许多意义上，它们是相似的词，描述语言如换工作的*规则*。它们有一些微妙的不同，但是大部分对于我们在这里的
> 讨论无关紧要。JS 的文法是一种结构化的方式，来描述语法（操作符，关键字，等等）如何组合在一起形成结构良好，合法的程序。换句话说，抛开文法来讨论语法将会忽略许多重要的细节。所以我们在本章中
> 注目的内容的最准确的描述是*文法*，尽管语言中的纯语法才是开发者们直接交互的。

## 语句与表达式

一个很常见的现象是，开发者们假定“语句（statement）”和“表达式（expression）”是大致等价的。但是这里我们需要区分它们俩，因为在我们的 JS 程序中它们有一些非常重要的区别。

为了描述这种区别，让我们借用一下你可能更熟悉的术语：英语。

一个“句子（sentence）”是一个表达想法的词汇的完整构造。它由一个或多个“短语（phrase）”组成，它们每一个都可以用标点符号或连词（“和”，“或”等等）连接。一个短语本身可以由更小的短语组成。
一些短语是不完整的，而且本身没有太多含义，而另一些短语可以自成一句。这些规则总体的称为英语的*文法*。

JS 文法也类似。语句就是句子，表达式就是短语，而操作符就是连词/标点。

JS 中的每一个表达式都可以被求值而成为一个单独的，具体的结果值。举例来说：

```javascript
var a = 3 * 6
var b = a
b
```

在这个代码段中，`3 * 6`是一个表达式（求值为`18`）。而第二行的`a`也是一个表达式，第三行的`b`也一样。对表达式`a`和`b`求值都会得到当时存储在这些变量中的值，也就是`18`。

另外，这三行的每一行都是一个包含表达式的语句。`var a = 3 * 6`和`var b = a`称为“声明语句（declaration statements）”因为它们每一个都声明了一个变量（并选择性地给它赋值）。
赋值`a = 3 * 6`和`b = a`（除去`var`）被称为赋值表达式（assignment expressions）。

第三行仅仅含有一个表达式`b`，但是它本身也是一个语句（虽然不是非常有趣的一个！）。这一般称为一个“表达式语句（expression statement）”。

### 语句完成值

一个鲜为人知的事实是，所有语句都有完成值（即使这个值只是`undefined`）。

你要如何做才能看到一个语句的完成值呢？

最明显的答案是把语句敲进你的浏览器开发者控制台，因为当你运行它时，默认的控制台会报告最近一次执行的语句的完成值。

让我们考虑一下`var b = a`。这个语句的完成值是什么？

`b = a`赋值表达式给出的结果是被赋予的值（上面的`18`），但是`var`语句本身给出的结果是`undefined`。为什么？因为在语言规范中`var`语句就是这么定义的。
如果你在你的控制台中敲入`var a = 42`，你会看到`undefined`被报告而不是`42`。

> [!NOTE]
> 技术上讲，事情要比这复杂一些。在 ES5 语言规范，12.2 部分的“变量语句”中，`VariableDeclaration`算法实际上返回了一个值（一个包含被声明变量的名称的`string` —— 诡异吧！？），
> 但是这个值基本上被`VariableStatement`算法吞掉了（除了在`for..in`循环中使用），而这强制产生一个空的（也就是`undefined`）完成值。

事实上，如果你曾经在你的控制台上（或者一个 JS 环境的 REPL —— read/evaluate/print/loop 工具）做过很多的代码实验的话，你可能看到过许多不同的语句都报告`undefined`，
而且你也许从来没理解它是什么和为什么。简单地说，控制台仅仅报告语句的完成值。

但是控制台打印出的完成值并不是我们可以在程序中使用的东西。那么我们该如何捕获完成值呢？

这是一个更加复杂的任务。在我们解释*如何*之前，让我们先探索一下*为什么*你想这样做。

我们需要考虑其他类型的语句的完成值。例如，任何普通的`{ .. }`块儿都有一个完成值，即它所包含的最后一个语句/表达式的完成值。

考虑如下代码：

```javascript
var b
if (true) {
  b = 4 + 38
}
```

如果你将这段代码敲入你的控制台/REPL。你可能会看到它报告`42`，因为`42`是`if`块儿的完成值，它取自`if`的最后一个赋值表达式语句`b = 4 + 38`。

换句话说，一个块的完成值就像*隐式的返回*块儿中的最后一个语句的值。

> [!NOTE]
> 这在概念上与 CoffeeScript 这样的语言很类似，它们隐含地从`function`中`return`值，这些值与函数中最后一个语句的值是相同的。

但这里有一个明显的问题。这样的代码是不工作的：

<!-- prettier-ignore -->
```javascript
var a, b

a = if (true) {
  b = 4 + 38
}
```

我们不能以任何简单的语法/文法来捕获一个语句的完成值并将它赋值给另一个变量（至少现在还不能！）。

那么，我们能做什么？

> [!WARNING]
> 仅用于演示的目的 —— 不要实际地在你的真实代码中做如下内容！

我们可以使用臭名昭著的`eval(..)`（有时读成“evil”）函数来捕获这个完成值。

```javascript
var a, b

a = eval('if (true) { b = 4 + 38 }')

a // 42
```

啊呀呀。这太难看了。但是这好用！而且它展示了语句的完成值是一个真实的东西，不仅仅是在控制台中，还可以在我们的程序中被捕获。

有一个称为“do 表达式”的 ES7 提案。这是它可能工作的方式：

```javascript
var a, b

a = do {
  if (true) {
    b = 4 + 38
  }
}

a // 42
```

`do { .. }`表达式执行一个块儿（其中有一个或多个语句），这个块儿中的最后一个语句的完成值将成为`do`表达式的完成值，它可以像展示的那样被赋值给`a`。

这里的大意是能够将语句作为表达式对待 —— 它们可以出现在其他语句内部 —— 而不必将它们包装在一个内联的函数表达式中，并实施一个明确的`return ..`。

到目前为止，语言的完成值不过是一些琐碎的事情。不过随着 JS 的进化它们的重要性可能会进一步提高，而且很有希望的是`do { .. }`表达式将会降低使用`eval(..)`这样的东西的冲动。

> [!WARNING]
> 重复我方才的训诫：避开`eval(..)`。真的。更多解释参见本系列的*作用域与闭包*一书。

### 表达式副作用

大多数表达式没有副作用。例如：

```javascript
var a = 2
var b = a + 3
```

表达式`a + 3`本身没有副作用，例如改变`a`。它有一个结果，就是`5`，而且这个结果在语句`b = a + 3`中被赋值给`b`。

一个最常见的（可能）带有副作用的表达式的例子是函数调用表达式：

```javascript
function foo() {
  a = a + 1
}

var a = 1
foo() // 结果：`undefined`， 副作用：改变`a`
```

还有其他的副作用表达式。例如：

```javascript
var a = 42
var b = a++
```

表达式`a++`有两个分离的行为。_首先_，它返回`a`的当前值，也就是`42`（然后它被赋值给`b`）。但*接下来*，它改变`a`本身的值，将它增加`1`。

```javascript
var a = 42
var b = a++

a // 43
b // 42
```

许多开发者错误的认为`b`和`a`一样拥有值`43`。这种困惑源自没有完全考虑`++`操作符的副作用在*什么时候*发生。

`++`递增操作符和`--`递减操作符都是一元操作符（见第四章），它们既可以用于后缀（“后面”）位置也可以用于前缀（“前面”）位置。

```javascript
var a = 42

a++ // 42
a // 43

++a // 44
a // 44
```

当`++`像`++a`这样用于前缀位置时，它的副作用（递增`a`）发生在值从表达式中返回*之前*，而不是`a++`那样发生在*之后*。

> [!NOTE]
> 你认为`++a++`是一个合法的语法吗？如果你试一下，你将会得到一个`ReferenceError`错位，但为什么？因为有副作用的操作符**要求一个变量引用**来作为它们副作用的目标。对于`++a++`来说，`a++`
> 这部分会首先被求值（因为操作符优先级 —— 参见下面的讨论），它会给出`a`在递增*之前*的值。但然后它试着对`++42`求值，这将（如果你试一下）会给出相同的`ReferenceError`错误，因为`++`
> 不能直接在`42`这样的值上施加副作用。

有时它会被错误地认为，你可以通过将`a++`包进一个`( )`中来将它的副作用封装起来，比如：

<!-- prettier-ignore -->
```javascript
var a = 42
var b = (a++)

a // 43
b // 42
```

不幸的是，`( )`本身不会像我们希望的那样，定义一个新的被包装的表达式，而它会在`a++`表达式的*副作用*之*后*求值。事实上，就算它能，`a++`也会首先返回`42`，而且除非你有另一个表达式在`++`
的副作用之后对`a`再次求值，你也不会从这个表达式中得到`43`，于是`b`不会被赋值为`43`。

虽然，有另一种选择：`,`语句序列逗号操作符。这个操作符允许你将多个独立的表达式语句连成一个单独的语句：

<!-- prettier-ignore -->
```javascript
var a = 42, b;
b = (a++, a);

a // 43
b // 43
```

> [!NOTE]
>
> `a++, a`周围的`( .. )`是必需的。其原因的操作符优先级，我们将会在本章后面讨论。

表达式`a++, a`意味着第二个`a`语句表达式会在第一个`a++`语句表达式的*副作用*之*后*进行求值，这表明它为`b`的赋值返回`43`。

另一个副作用操作符的例子是`delete`。正如我们在第二章中展示的，`delete`用于从一个`object`或一个`array`值槽中移除一个属性。但它经常做为一个独立语句被调用：

```javascript
var obj = {
  a: 42,
}

obj.a // 42
delete obj.a // true
obj.a // undefined
```

如果被请求的操作是合法/可允许的，`delete`操作符的结果值为`true`，否则结果为`false`。但是这个操作符的副作用是它移除了属性（或数组值槽）。

> [!NOTE]
> 我们说合法/可允许是什么意思？不存在的属性，或存在且可配置的属性（见本系列*this 与对象原型*的第三章）将会从`delete`操作符中返回`true`。否则，其结果将是`false`或一个错误。

副作用操作符的最后一个例子，可能既是明显的也是不明显的，是`=`赋值操作符。

考虑如下代码：

```javascript
var a

a = 42 // 42
a // 42
```

对于这个表达式来说，`a = 42`中的`=`看起来似乎不是一个副作用操作符。但如果我们检视语句`a = 42`的结果值，会发现它就是刚刚被赋予的值（`42`），所以将相同的值赋予`a`实质上是一种副作用。

> [!TIP]
> 相同的原因也适用于`+=`，`-=`这样的复合操作符的副作用。例如`a = b += 2`被处理为首先进行`b += 2`（也就是`b = b + 2`），然后这个赋值的结果被赋予`a`。

这种赋值表达式（语句）得出被赋予的值的行为，主要在式赋值上十分有用，就像这样：

```javascript
var a, b, c

a = b = c = 42
```

这里，`c = 42`被求值得出`42`（带有将`42`赋值给`c`的副作用），然后`b = 42`被求值得出`42`（带有将`42`赋值给`b`的副作用），而最后`a = 42`被求值（带有将`42`赋值给`a`的副作用）。

> [!WARNING]
> 一个开发者们常犯的错误是将链式赋值写成`var a = b = 42`这样。虽然这看起来是相同的东西，但它不是。如果这个语句发生在没有另外分离的`var b`（在作用域的某处）来正式声明它的情况下，
> 那么`var a = b = 42`将不会直接声明`b`，根据`strict`模式的状态，它要么抛出一个错误，要么无意中创建一个全局变量（参见本系列*作用域与闭包*）。

另一个要考虑的场景是：

```javascript
function vowels(str) {
  var matches

  if (str) {
    // 找出所有的元音字母
    matches = str.match(/[aeiou]/g)

    if (matches) {
      return matches
    }
  }
}

vowels('Hello World') // ['e', 'o', 'o']
```

这可以工作，而且许多开发者喜欢这么做。但是使用一个我们可以利用赋值副作用的惯用法，可以将两个`if`语句组合为一个来进行简化：

```javascript
function vowels(str) {
  var matches

  if (str && (matches = str.match(/aeiou/g))) {
    return matches
  }
}

vowels('Hello World') // ['e', 'o', 'o']
```

> [!NOTE]
>
> `matches = str.match..`周围的`( .. )`是必需的。其原因是操作符优先级，我们将在本章稍后的“操作符优先级”一节中讨论。

我偏好这种短一些的风格，因为我认为它明白的表示了两个条件其实是有关联的，而非分离的。但是与大多数 JS 中的风格选择一样，哪一种*更好*纯粹是个人意见。

### 上下文规则
