# :zzz:

[《你不知道的 JavaScript》](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/types%20%26%20grammar/ch4.md)

# 强制转换

现在我们更全面地了解了 JS 的类型和值，我们将注意力转向一个极具争议的话题：强制转换。

正如我们在第一章中提到的，关于强制转换到底是一个有用的特性，还是一个语言设计上的缺陷（或介于两者之间！），早就开始争论不休了。正如你读过关于 JS 的
其他书籍，你就会知道流行在市面上那种淹没一切的*声音*：强制转换是魔法，是邪恶的，令人困惑的，而且就是彻头彻尾的坏主意。

本着这个系列丛书的总体精神，我认为你应当直面你不理解的东西并设法更全面地*搞懂它*。而不是因为大家都这样做，或是你曾经被一些怪东西咬到就逃避强制转换。

我们的目标是全面地探索强制转换的优点和缺点（是的，它们*有*优点！），这样你就能在程序中对它是否合适做出明智的决定。

## 转换值

将一个值从一个类型明确地转换到另一个类型称为“类型转换（type casting）”，当这个操作隐含地完成时称为“强制转换（coercion）”（根据一个值如何被使用的规则来强制它变换类型）。

> [!NOTE]
> 这可能不明显，但是 JS 强制转换总是得到基本标量值的一种，比如`string`、`number`或`boolean`。没有强制转换可以得到像`object`和`function`这样的复杂值。
> 第三章讲解了“封箱”，它将一个基本类型标量值包装在它们相应的`object`中，但在准确的意义上这不是真正的强制转换。

另一种区别这些术语的常见方法是：“类型转换（type casting/conversion）”发生在静态类型语言的编译时，而“类型强制转换（type coercion）”是动态类型语言的运行时转换。

然而，在 JS 中，大多数人都将所有这些类型的转换都称为*强制转换（coercion）*，所以我偏好的区别方式使用“隐式强制转换（implicit coercion）”与“明确强制转换（explicit coercion）”。

其中的区别应当是很明显的：在观察代码时如果一个类型转换明显是有意为之的，那么它就是“明确强制转换”，而如果这个类型转换是作为其他操作的不那么明显的副作用发生的，那么它就是“隐式强制转换”。

例如，考虑这两种强制转换的方式：

```javascript
var a = 42

var b = a + '' // 隐式强制转换

var c = String(a) // 明确强制转换
```

对于`b`来说，强制转换是隐式发生的，因为如果与`+`操作符组合的操作数之一是一个`string`值（`""`），这将使`+`操作成为一个`string`连接（将两个字符
加在一起串），而`string`连接的*一个（隐藏的）副作用*是将`a`中的值`42`强制转换为它的`string`等价物：`"42"`。

相比之下，`String(..)`函数使一切相当明显，它明确地取得`a`中的值，并把它强制转换为一个`string`表现形式。

两种方式都能达到相同的效果：从`42`变成`"42"`。但它们*如何*达到这种效果，才是关于 JS 强制转换的热烈争论的核心。

> [!NOTE]
> 技术上讲，除了文体上的差异，还有一些细微的行为差异。我们将在本章稍后，“隐式地：Strings <--> Numbers”一节中自己讲解。

“明确地”、“隐式地”或“明显地”和“隐藏的副作用”这些术语，是*相对的*。

如果你确切的知道`a + ''`是在做什么，并且你有意地这么做来强制转换一个`string`，你可能感觉这个操作已经足够“明确”了。相反，如果你从没见过`String(..)`函数被用于`string`
强制转换，那么对于来说它的行为可能看起来太过隐蔽而让你感到“隐含”。

但我们是基于一个*大众的，充分了解，但不是专家或 JS 规范爱好者的*开发者的观点来讨论“明确”与“隐式”的。无论你的程度如何，或是没有在这个范畴内准确地找到自己，你都需要根据我们在这里的观察方式，相应地调整你的角度。

> [!TIP]
> 我们自己写代码而且也只有我们自己会读它，通常是少见的。即便你是一个精通 JS 里里外外的专家，也要考虑一个经验没那么丰富的队友在读你的代码时的感受如何。对于他们和对于你来说，“明确”或“隐含”的意义相同吗？

## 抽象值操作

在我们可以探究*明确*与*隐含*强制转换之前，我们需要学习一些基本规则，是它们控制着值如何*变成*一个`string`、`number`或`boolean`的。ES5 语言规范的第九部分用值的变形规则定义了
几种“抽象操作”（“仅供内部使用的操作”的高大上说法）。我们将特别关注于：`ToString`、`ToNumber`、和`ToBoolean`，并稍稍关注一下`ToPrimitive`。

### `ToString`

当任何一个非`string`值被强制转换为一个`string`表现形式时，这个转换的过程是由语言规范的 9.8 部分的`ToString`抽象操作处理的。

内建的基本类型值拥有自然的字符串化形式：`null`变为`"null"`，`undefined`变为`"undefined"`，`true`变为`"true"`。`number`一般会以你期望的自然方式表达，
但正如我们在第二章中讨论的，非常小或非常大的`number`将会以指数形式表达：

```javascript
// `1.07 乘以 `1000`， 7次
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000

// 3位乘以7次 = 21位
a.toString() // "1.07e21"  Chrome 127 显示： "1.07e+21"
```

对于普通的对象，除非你指定你自己的，默认的`toString()`（可以在`Object.prototype.toString()`找到）将返回*内部`[[Class]]`*（见第三章），例如`"[object Object]"`。

但正如早先所展示的，如果一个对象上拥有它自己的`toString()`方法，而你又以一种类似`string`的方式使用这个对象，那么它的`toString()`将会被自动调用，而且这个调用的`string`结果将被使用。

> [!NOTE]
> 技术上讲，一个对象被强制转换为一个`string`要通过`ToPrimitive`抽象操作（ES5 规范，9.1 部分），但是那其中的微妙细节将会在本章稍后的`ToNumber`部分中讲解，所以我们在这里先跳过它。

数组拥有一个覆盖版本的默认`toString()`，将数组字符串化为它所有的值（每个都字符串化）的（字符串）连接，并用`","`分割每个值。

```javascript
var a = [1, 2, 3]

a.toString() // "1,2,3"
```

重申一遍，`toString()`可以明确地被调用，也可以通过在一个需要`string`的上下文环境中使用一个非`string`来自动地被调用。

#### JSON 字符串化

另一种看起来与`ToString`密切相关的操作是，使用`JSON.stringify(..)`工具将一个值序列化为一个 JSON 兼容的`string`值。

重要的是要注意，这种字符串化与强制转换并不完全是同一种东西。但是因为它与上面讲的`ToString`规则有关联，我们将在这里稍微转移一下话题，来讲解 JSON 字符串化行为。

对于最简单的值，JSON 字符串化行为基本上和`toString()`转换是相同的，除了序列化的结果*总是一个`string`*：

```javascript
JSON.stringify(42) // "42"
JSON.stringify('42') // ""42"" （注意：一个包含双引号的字符串）
JSON.stringify(null) // "null"
JSON.stringify(true) // "true"
```

任何*JSON 安全*的值都可以被`JSON.stringify(..)`字符串化。但是什么是*JSON 安全的？*任何可以用 JSON 表现形式合法表达的值。

考虑 JSON**不**安全的值可能更容易一些。一些例子是：`undefined`、`function`、（ES6+）`symbol`和带有循环引用的`object`（一个对象结构中的属性相互引用造成了一个永不终结的循环）。
对于标准的 JSON 结构来说这些都是非法的值，主要是因为它们不能移植到使用 JSON 值的其他语言中。

`JSON.stringify(..)`工具在遇到`undefined`、`function`和`symbol`时将会自动地忽略它们。如果在一个`array`中遇到这样的值，它会被替换为`null`（这样数组的位置信息就不会改变）。
如果在一个`object`的属性中遇到这样的值，这个属性会被简单地剔除掉。

考虑下面的代码：

```javascript
JSON.stringify(undefined) // undefined
JSON.stringify(function () {}) // undefined

JSON.stringify([1, undefined, function () {}, 4]) // "[1,null,null,4]"
JSON.stringify({ a: 2, b: function () {} }) // "{"a":2}"
```

但如果你试着`JSON.stringify(..)`一个带有循环引用的`object`，就会抛出一个错误。

JSON 字符串化有一个特殊行为，如果一个`object`值定义了一个`toJSON()`方法，这个方法将会被首先调用，以取得用于序列化的值。

如果你打算 JSON 字符串化一个可能含有非法 JSON 值的对象，或者如果这个对象中正好有不适于序列化的值，那么你就应当为它定义一个`toJSON()`方法，返回这个`object`的一个*JSON 安全*版本。

例如：

```javascript
var o = {}

var a = {
  b: 42,
  c: o,
  d: function () {},
}

// 在 `a` 内部制造一个循环引用
o.e = a

// 这会因为循环引用而抛出一个错误
// JSON.stringify(a)

// 自定义一个 JSON 值序列化
a.toJSON = function () {
  // 序列化仅包含属性 `b`
  return { b: this.b }
}

JSON.stringify(a) // "{"b":42}"
```

一个很常见的误解是，`toJSON()`应当返回一个 JSON 字符串化的表现形式。这可能是不正确的，除非你事实上想要字符串化`string`本身（通常不会！）。`toJSON()`应当返回合适的实际
普通值（无论什么类型），而`JSON.stringify(..)`自己会处理字符串化。

换句话说，`toJSON()`应当翻译为：“变为一个适用于字符串化的 JSON 安全的值”，而不是像许多开发者错误认为的那样，“变为一个 JSON 字符串”。

考虑下面的代码：

```javascript
var a = {
  val: [1, 2, 3],

  // 可能正确！
  toJSON: function () {
    return this.val.slice(1)
  },
}

var b = {
  val: [1, 2, 3],

  // 可能不正确！
  toJSON: function () {
    return '[' + this.val.slice(1).join() + ']'
  },
}

JSON.stringify(a) // "[2,3]"

JSON.stringify(b) // ""[2,3]""
```

在第二个调用中，我们字符串化了返回的`string`而不是`array`本身，这可能不是我们想要做的。

既然我们说到了`JSON.stringify(..)`，那么就让我们来讨论一些不那么广为人知，但是仍然很有用的功能吧。

`JSON.stringify(..)`的第二个参数值是可选的，它称为*替换器（replacer）*。这个参数既可以是一个`array`也可以是一个`function`。与`toJSON()`为序列化准备一个值的方式类似，它提供
一种过滤机制，指出一个`object`的哪一个属性应该或不应该包含在序列化形式中，来自定义这个`object`的递归序列化行为。

如果*替换器*是一个`array`，那么它应当是一个`string`的`array`，它的每一个元素指定了允许包含在这个`object`的序列化形式中的属性名称。如果一个属性不存在于这个列表中，那么它就会被跳过。

如果*替换器*是一个`function`，那么它会为`object`本身而被调用一次，并且为这个`object`中的每一个属性都被调用一次，而且每次都被传入两个参数值，*key*和*value*。要在序列化中跳过
一个*key*，可以返回`undefined`。否则，就返回被提供的*value*。

```javascript
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3],
}

JSON.stringify(a, ['b', 'c']) // "{"b":42,"c":"42"}"

JSON.stringify(a, function (k, v) {
  if (k !== 'c') return v
})
// "{"b":42,"d":[1,2,3]}"
```

> [!NOTE]
> 在`function`*替换器*的情况下，第一次调用 key 参数`k`是`undefined`（而对象`a`本身会被传入）。`if`语句会**过滤掉**名称为`c`的属性。字符串化是递归的，所以数组`[1, 2, 3]`
> 会将它的每一个值（`1`、`2`和`3`）都作为`v`传递给`替换器`，并将索引值（`0`、`1`和`2`）作为`k`。

`JSON.stringify(..)`还可以接收第三个可选参数值，称为*填充符（space）*，在对人类有好的输出中它被用作缩进。*填充符*可以是一个正整数，用来指示每一级
缩进中应当使用多少个空格字符。或者，*填充符*可以是一个`string`，这时每一级缩进将会使用它的前十个字符。

```javascript
var a = {
  b: 42,
  c: '42',
  d: [1, 2, 3],
}

JSON.stringify(a, null, 3)
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify(a, null, '-----')
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

记住，`JSON.stringify(..)`并不直接是一种强制转换的形式。但是，我们在这里讨论它，是由于两个与`ToString`强制转换有关联的行为：

1. `string`、`number`、`boolean`和`null`值在 JSON 字符串化时，与它们通过`ToString`抽象操作的规则强制转换为`string`值的方式基本上是相同的。

2. 如果传递一个`object`值给`JSON.stringify(..)`，而这个`object`上拥有一个`toJSON()`方法，那么在字符串化之前，`toJSON()`就会被自动调用来将这个值（某种意义上）“强制转换”为*JSON 安全*的。
